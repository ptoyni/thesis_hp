# Layout Vs Schematic (LVS)

After a layout has been verified for physical manufacturability through Design Rule Checking (DRC), the next essential step is to confirm its **electrical correctness** with respect to the original schematic. This verification step is known as **Layout Vs Schematic (LVS)**. Whereas DRC ensures that the physical geometry can be fabricated, LVS ensures that the fabricated geometry will function as intended by the circuit design. Together, DRC and LVS form the core of the **physical verification** process that bridges the logical and geometric domains of IC design.


## Fundamentals of LVS

*Layout Vs Schematic* comparison is a **netlist-based verification process**. It compares the electrical connectivity extracted from the physical layout with that defined in the schematic. During LVS, the tool first performs **netlist extraction** from the layout (parsing all transistors, polygons, capacitors, and interconnects), and then compares this extracted netlist against the schematic netlist. The goal is to verify that both represent the same electrical circuit — that is, the same devices, same connections, and identical hierarchy.

Typical checks performed during LVS include:  
- **Device recognition**: confirming that every transistor or passive component in the layout corresponds to a schematic element.  
- **Pin and net matching**: ensuring all connections and signal names align between the two domains.  
- **Parameter equivalence**: verifying that critical parameters such as transistor width, length, and multiplicity match (number of fingers).  

If all devices and nets correspond correctly, the design is said to be **LVS clean**. Otherwise, the LVS report lists mismatches that must be corrected before fabrication.


## Importance in the Design Flow

While DRC ensures *how* a design can be fabricated, LVS ensures *what* will be fabricated. Even a DRC-clean layout can fail to perform correctly if a wire is connected to the wrong node, a transistor terminal is swapped, or a device is missing. Such errors may lead to functional failure, excessive power consumption, or biasing issues that are difficult to detect without LVS.  

Therefore, LVS verification is critical before tape-out because it confirms the **topological equivalence** between the intended circuit (schematic) and its physical realization (layout).  
It ensures that all devices, interconnects, and terminals have been represented faithfully, safeguarding against layout-level errors that could otherwise result in costly re-fabrications.


## Practical Implementation

In this work, LVS verification was carried out using **KLayout** in combination with the **IHP SG13G2 PDK** inside the **IIC-OSIC Docker environment**.  
However, due to the known limitation that Qt-based LVS functions do not operate within the Dockerized KLayout interface, LVS must be performed **externally in the Docker terminal** using a *Python script provided by the IHP PDK*.  

::: callout-note
## LVS Script 

The LVS verification script provided with the **IHP SG13G2 PDK** can be found at:

`/foss/pdks/ihp-sg13g2/libs.tech/klayout/tech/lvs/`

The main Python file, **`run_lvs.py`**, executes the complete LVS procedure.
:::

This LVS script automates the comparison between the schematic netlist and the layout. To execute it, the user provides three key inputs:

- The **schematic netlist** (in SPICE format, generated from schematic in Xschem)  
- The **layout GDSII file** (the physical design)  
- The **output directory** for output file publication  

Once executed, the script performs layout netlist extraction, mapping, and comparison against the schematic. It then produces several output files, typically including:

- **`.lvsdb`** — the LVS database containing the extracted and compared netlists with in-depth details 
- **`.cir`** — the extracted SPICE-format netlist from the layout containing circuit description 
- **`.log`** — the report of information such as name of files, tool version and error if encountered

::: callout-note
## Important Naming Consistency  

For LVS to run successfully, the **schematic name**, **GDS file name**, **SPICE netlist name**, and the **top-cell name** inside the GDS must all be **identical**.  
If any of these names differ, the Python script will terminate with an unexpected error because it cannot match the top-level hierarchy between schematic and layout.
:::


## Interpreting and Visualizing LVS Results in KLayout

After running the LVS script in the terminal, the generated `.lvsdb` file can be opened in **KLayout** for detailed inspection and mapping. To do this, open the corresponding GDS layout in KLayout, then navigate to:

> **Tools → Netlist Browser**

This opens the Netlist Browser catalog window. Within this interface, load the `.lvsdb` file generated by the script. When the .lvsdb file is opened in the Netlist Database Browser within KLayout, a catalog window appears with four main tabs — **Netlist, Schematic, Cross Reference, and Log**.
The Cross Reference tab displays a side-by-side comparison between the layout and reference schematic, listing all pins, nets, and devices in both domains. Matched elements are shown in green, indicating full correspondence between schematic and layout, as illustrated in Figure below (example: analog_inverter).

![Netlist Browser to view LVSDB files and trace nets](../figures/_fig_lvs_box.jpg){#fig-lvs}

If mismatches occur, the differences are highlighted in red, showing missing devices, incorrect connections, or parameter discrepancies. These issues are further detailed in the Log tab, which provides textual summary of each error and its location in the design. This visualization enables efficient debugging by allowing the designer to inspect each net and device interactively, ensuring complete electrical equivalence before declaring the layout LVS-clean.

Klayout also provides powerful **tracing functionality**, allowing designers to visually select and highlight individual devices or nets within the layout to locate mismatches precisely.  
This interactive feedback significantly accelerates debugging and helps ensure that every element is electrically connected as intended.


In summary, LVS is the final and most critical step in confirming that a verified, DRC-clean layout is also **electrically identical** to its schematic representation. By performing LVS through the IHP-provided Python script and analyzing results within KLayout, the design achieves both physical and electrical closure.  
The successful completion of this step certifies that the layout accurately implements the intended circuit topology, allowing it to proceed confidently toward **parasitic extraction and post-layout simulation**, and ultimately, **fabrication**.
