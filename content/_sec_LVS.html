<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>sec_lvs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_sec_LVS_files/libs/clipboard/clipboard.min.js"></script>
<script src="_sec_LVS_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="_sec_LVS_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="_sec_LVS_files/libs/quarto-html/popper.min.js"></script>
<script src="_sec_LVS_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_sec_LVS_files/libs/quarto-html/anchor.min.js"></script>
<link href="_sec_LVS_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_sec_LVS_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_sec_LVS_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_sec_LVS_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_sec_LVS_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="layout-versus-schematic-lvs" class="level1">
<h1>Layout Versus Schematic (LVS)</h1>
<p>After a layout has been verified for physical manufacturability through Design Rule Checking (DRC), the next essential step is to confirm its <strong>electrical correctness</strong> with respect to the original schematic. This verification step is known as <strong>Layout Versus Schematic (LVS)</strong>. Whereas DRC ensures that the physical geometry can be fabricated, LVS ensures that the fabricated geometry will function as intended by the circuit design. Together, DRC and LVS form the core of the <strong>physical verification</strong> process that bridges the logical and geometric domains of IC design.</p>
<section id="fundamentals-of-lvs" class="level2">
<h2 class="anchored" data-anchor-id="fundamentals-of-lvs">Fundamentals of LVS</h2>
<p><em>Layout Versus Schematic</em> comparison is a <strong>netlist-based verification process</strong>. It compares the electrical connectivity extracted from the physical layout with that defined in the schematic. During LVS, the tool first performs <strong>netlist extraction</strong> from the layout (parsing all transistors, polygons, capacitors, and interconnects), and then compares this extracted netlist against the schematic netlist. The goal is to verify that both represent the same electrical circuit — that is, the same devices, same connections, and identical hierarchy.</p>
<p>Typical checks performed during LVS include:<br>
- <strong>Device recognition</strong>: confirming that every transistor or passive component in the layout corresponds to a schematic element.<br>
- <strong>Pin and net matching</strong>: ensuring all connections and signal names align between the two domains.<br>
- <strong>Parameter equivalence</strong>: verifying that critical parameters such as transistor width, length, and multiplicity match (number of fingers).</p>
<p>If all devices and nets correspond correctly, the design is said to be <strong>LVS clean</strong>. Otherwise, the LVS report lists mismatches that must be corrected before fabrication.</p>
</section>
<section id="importance-of-lvs-in-the-design-flow" class="level2">
<h2 class="anchored" data-anchor-id="importance-of-lvs-in-the-design-flow">Importance of LVS in the Design Flow</h2>
<p>While DRC ensures <em>how</em> a design can be fabricated, LVS ensures <em>what</em> will be fabricated. Even a DRC-clean layout can fail to perform correctly if a wire is connected to the wrong node, a transistor terminal is swapped, or a device is missing. Such errors may lead to functional failure, excessive power consumption, or biasing issues that are difficult to detect without LVS.</p>
<p>Therefore, LVS verification is critical before tape-out because it confirms the <strong>topological equivalence</strong> between the intended circuit (schematic) and its physical realization (layout).<br>
It ensures that all devices, interconnects, and terminals have been represented faithfully, safeguarding against layout-level errors that could otherwise result in costly re-fabrications.</p>
</section>
<section id="practical-implementation" class="level2">
<h2 class="anchored" data-anchor-id="practical-implementation">Practical Implementation</h2>
<p>In this work, LVS verification was carried out using <strong>KLayout</strong> in combination with the <strong>IHP SG13G2 PDK</strong> inside the <strong>IIC-OSIC Docker environment</strong>.<br>
However, due to the known limitation that Qt-based LVS functions do not operate within the Dockerized KLayout interface, LVS must be performed <strong>externally in the Docker terminal</strong> using a <em>Python script provided by the IHP PDK</em>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LVS Script
</div>
</div>
<div class="callout-body-container callout-body">
<p>The LVS verification script provided with the <strong>IHP SG13G2 PDK</strong> can be found at:</p>
<p><code>/foss/pdks/ihp-sg13g2/libs.tech/klayout/tech/lvs/</code></p>
<p>The main Python file, <strong><code>run_lvs.py</code></strong>, executes the complete LVS procedure.</p>
</div>
</div>
<p>This LVS script automates the comparison between the schematic netlist and the layout. To execute it, the user provides three key inputs:</p>
<ul>
<li>The <strong>schematic netlist</strong> (in SPICE format, generated from schematic in Xschem)<br>
</li>
<li>The <strong>layout GDSII file</strong> (the physical design)<br>
</li>
<li>The <strong>output directory</strong> for output file publication</li>
</ul>
<p>Once executed, the script performs layout netlist extraction, mapping, and comparison against the schematic. It then produces several output files, typically including:</p>
<ul>
<li><strong><code>.lvsdb</code></strong> — the LVS database containing the extracted and compared netlists with in-depth details</li>
<li><strong><code>.cir</code></strong> — the extracted SPICE-format netlist from the layout containing circuit description</li>
<li><strong><code>.log</code></strong> — the report of information such as name of files, tool version and error if encountered</li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important Naming Consistency
</div>
</div>
<div class="callout-body-container callout-body">
<p>For LVS to run successfully, the <strong>schematic name</strong>, <strong>GDS file name</strong>, <strong>SPICE netlist name</strong>, and the <strong>top-cell name</strong> inside the GDS must all be <strong>identical</strong>.<br>
If any of these names differ, the Python script will terminate with an unexpected error because it cannot match the top-level hierarchy between schematic and layout.</p>
</div>
</div>
</section>
<section id="interpreting-and-visualizing-lvs-results-in-klayout" class="level2">
<h2 class="anchored" data-anchor-id="interpreting-and-visualizing-lvs-results-in-klayout">Interpreting and Visualizing LVS Results in KLayout</h2>
<p>After running the LVS script in the terminal, the generated <code>.lvsdb</code> file can be opened in <strong>KLayout</strong> for detailed inspection and mapping. To do this, open the corresponding GDS layout in KLayout, then navigate to:</p>
<blockquote class="blockquote">
<p><strong>Tools → Netlist Browser</strong></p>
</blockquote>
<p>This opens the Netlist Browser catalog window. Within this interface, load the <code>.lvsdb</code> file generated by the script. When the .lvsdb file is opened in the Netlist Database Browser within KLayout, a catalog window appears with four main tabs — <strong>Netlist, Schematic, Cross Reference, and Log</strong>. The Cross Reference tab displays a side-by-side comparison between the layout and reference schematic, listing all pins, nets, and devices in both domains. Matched elements are shown in green, indicating full correspondence between schematic and layout, as illustrated in Figure X (example: analog_inverter).</p>
<p>If mismatches occur, the differences are highlighted in red, showing missing devices, incorrect connections, or parameter discrepancies. These issues are further detailed in the Log tab, which provides textual summary of each error and its location in the design. This visualization enables efficient debugging by allowing the designer to inspect each net and device interactively, ensuring complete electrical equivalence before declaring the layout LVS-clean.</p>
<p>Klayout also provides powerful <strong>tracing functionality</strong>, allowing designers to visually select and highlight individual devices or nets within the layout to locate mismatches precisely.<br>
This interactive feedback significantly accelerates debugging and helps ensure that every element is electrically connected as intended.</p>
<p>In summary, LVS is the final and most critical step in confirming that a verified, DRC-clean layout is also <strong>electrically identical</strong> to its schematic representation. By performing LVS through the IHP-provided Python script and analyzing results within KLayout, the design achieves both physical and electrical closure.<br>
The successful completion of this step certifies that the layout accurately implements the intended circuit topology, allowing it to proceed confidently toward <strong>parasitic extraction and post-layout simulation</strong>, and ultimately, <strong>fabrication</strong>.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>