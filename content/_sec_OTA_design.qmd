

## OTA Design

The focus of our thesis is designing and implementating error amplifier block within the selected buck converter
topology using Open Source Tools. This involves developing the block from initial specification and schematic design
through to layout, verification (including LVS and PEX), and final tapeout using exclusively open-source tools and
IHP-SG13G2 PDK. The goal is to create a high-performance, low-power error amplifier tailored to the requirements of the
mixed-signal LED driver IC, ensuring accurate regulation and stability of the control loop. This work will contribute a
critical building block to the overall ASIC design while also serving as a case study in open-source analog IC design
workflows.

The amplifier is tailored to meet the feedback stability and performance specifications of the LED driver
system operating within a 5 V output and 18–36 V input range.

In the section detailing buck converter control design (especially the voltage-mode control loop), @wicht2020 focuses
on: 

- A transconductance amplifier used as the error amplifier

- High open-loop gain

- A clear emphasis on stability, bandwidth, and linear range

- In most cases, the paper assumes low voltage domain

- The architectures shown are two-stage OTAs or folded cascode for high PSRR


Final Take:

Folded Cascode OTA (see @fig-foldedcascode-diagram) is very much aligned with @wicht2020 methodology, especially if our focus is on:

- A high-gain, linear, feedback-stage amplifier

- Working within 1.5V analog domain

- Dealing with moderate capacitive loads (e.g. compensation network / VCOMP node)

- @wicht2020 doesn’t enforce one architecture rigidly, but the characteristics described match folded cascode best.

![Topology](../figures/_fig_foldedcascode_diagram.svg){#fig-foldedcascode-diagram}


| **Parameter**     | **Target Value**          |
|-------------------|---------------------------|
| Bandwidth         | > 1 MHz                   |
| Phase Margin      | > 60°                     |
| Power Supply      | 1.5 V (AVDD)              |
| Load Capacitance  | ~1-2 pF                   |
| Power Consumption | < 1 mW                    |

: Finalised Specifications

## Into the design

As shown in the @fig-foldedcascode-diagram, $M_1$ and $M_2$ are the input differential pair mosfets with $M_5,_6$ and $M_7,_8$ as their cascoded mosfets.

::: {.callout-important title="Cascode Bias Voltage Generation"}
It is critically import for a stable performance across PVT that the bias voltages for the cascode gates are created in a manner that tracks variations with process, temperature, and supply voltage!
:::

The current mirror constructed out of $M_\mathrm{3,7}$ and $M_\mathrm{4,8}$ is a special kind of **cascode current
mirror for low-voltage operation**, also referred to as high-swing cascode current mirror [@Jespers_Murmann_2017]. This
type is very often used, as it forces the $V_{GS}$ and $V_{DS}$ of $M_{3,4}$ to be equal, so the current mirror ratio is
independent of $g_{ds}$.


## Sizing using $g_{m}$ over $I_d$ method{#sec-gmid-method}

In nanometer CMOS, the MOSFET behavior is much more complex than these simple models. Also, this highly simplified
derivations introduce concepts like the threshold voltage or the overdrive voltage, which are interesting from a
theoretical viewpoint, but bear little practical use. Modern compact MOSFET models (like the PSP model used in SG13G2)
use hundreds of parameters and fairly complex equations to somewhat properly describe MOSFET behavior over a wide range
of parameters like width, length and temperature. A modern approach to MOSFET sizing is thus based on the thought to use
exactly these MOSFET models, characterize them, put the resulting data into tables and charts, and thus learn about the
complex MOSFET behavior and use it for MOSFET sizing.

The gm over Id methodology has the huge advantage that it catches MOSFET behavior quite accurately over a wide range of
operating conditions, and the curves look very similar for pretty much all CMOS technologies, from micrometer bulk CMOS
down to nanometer FinFET devices. Of course the absolute values change, but the method applies universally.

We will be using the [pygmid tool](https://github.com/dreoilin/pygmid) which is included in IIC-OSIC-TOOLS and is
basically a python version of the gm/Id starter kit from Boris Murmann.



A brief implementation of this method is available
[here](https://github.com/dreoilin/pygmid)

Following is the python notebook designed for the sizing of Foldedcascode OTA with nmos differential input pair using
$g_{m}$ over $I_d$ method.



::: {.callout-note title="OTA Sizing" collapse="true"}
{{< embed ../sizing/python/sizing_foldedcascode_nmos.ipynb echo=true >}}
:::

## Complete Design and constant $g_m$ biasing using current mirrors

Based on the sizing procedure in @sec-gmid-method, we are ready with all the $W/L$ ratios and able to design the
complete OTA (see @fig-foldedcascode-xschem) 

![OTA design in Xschem](../figures/_fig_foldedcascode_xschem.svg){#fig-foldedcascode-xschem}

Find the schematic design [here](../Designs/otas/1_schematics/foldedcascode_nmos.sch)

### Discussion of the OTA Design

We will now do an analysis of the circuit design of the OTA including all the complications which make this design practical.

1. For easier navigation, the device identifier are consistent with the circuit sketch in @fig-foldedcascode-xschem.

2. Some MOSFET dimensions are rounded to make a better fit in the IC layout. Please also look carefully at $W$, $L$, and
   $\mathrm{ng}$. The parameter $\mathrm{ng}$ defines how the total $W$ of a MOSFET should be split into individual
   MOSFET fingers with $W_\mathrm{f} = W / \mathrm{ng}$. This is done to arrive at a suitably sized MOSFET physical
   implementation.

3. As you can (hopefully) see the circuit is carefully drawn to ease readability. Important nets are named, text
   comments state certain properties like nominal voltage levels, bias currents, etc. Current sensing elements are added
   to directly see the dc currents in the circuit simulation.

4. The bias voltage generation for the cascodes is included as well. The voltage drop for the bottom transistors is
   developed by properly scaling the MOSFETs in the reference branch. We reduce the $W/L$ ratio to increase the $V_{GS}$
   to create a voltage headroom for the bottom MOSFET.

5. Sensitive bias nodes are buffered with decoupling capacitors. We are using MOSFETs as nonlinear capacitors, which is
   not an issue in this application, but we value the increased capacitive density. Please note how the MOSFET are
   connected (some are tied to ${VDD}$ while others are tied to $V{SS}$).


## Simulation of the OTA{#sec-ota-simulation}

Now that circuit is ready we need to test its ac and transient behaviour as well as loop gain using Middlebrook's method
and Tian's method as mention in @fig-ac-xschem, @fig-tran-xschem, @fig-loopgain-xschem

::: {#fig-ac-xschem .figure}
![AC Analysis Setup](../figures/_fig_ac.svg)
:::

::: {#fig-ac-output-xschem .figure}
![AC Analysis Output](../figures/_fig_foldedcascode_ac_bode.svg)
:::

::: {#fig-tran-xschem .figure}
![Transient Analysis Setup](../figures/_fig_tran.svg)
:::

::: {#fig-tran-output-xschem .figure}
![Transient Analysis Output](../figures/_fig_foldedcascode_tran_combined.svg)
:::

::: {#fig-loopgain-xschem .figure}
![Loop Gain Setup](../figures/_fig_loopgain.svg)
:::


The loop gain analysis yeilds the following plots which clarifies that our specifications such as gain and phase margin
are met successfully. See @fig-loopgain-magnitude and @fig-loopgain-phase
The plots include both Middlebrook's and Tian's method for loop gain.


::: {#fig-loopgain-magnitude .figure}
![Magnitude middlebrook vs Tian](../figures/_fig_loopgain_magnitude.svg)
:::

::: {#fig-loopgain-phase .figure}
![Phase middlebrook vs Tian](../figures/_fig_loopgain_phase.svg)
:::




