[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Assessing the feasibility of developing and taping-out an analog block for LED driver control using IHP-Open-PDK and IIC-OSIC-TOOLS",
    "section": "",
    "text": "1 Abstract\nOpen-source EDA has reached a point where its practical viability for real mixed-signal IC fabrication can be examined on modern semiconductor processes. This thesis evaluates that potential through the design and tape-out of an analog block for LED-driver control using the IHP OpenPDK SG13G2 a 130 nm SiGe BiCMOS PDK and the implementation using the open-source IIC-OSIC-TOOLS developed by Prof. Pretl (JKU Linz)\nThe project follows a complete analog design cycle. System requirements are derived from an ideal reference schematic of a DC-DC LED-driver PMIC, modeled following the methodology from Prof. Bernhard Wicht’s book on design of power managemant ICs. From these constraints, we design an operational transconductance amplifier (OTA) intended to drive a specific load extracted from the system-level PMIC model. The electrical design is implemented in Xschem for schematic capture, Ngspice for pre-layout simulation, corner and Monte-Carlo analysis using CACE, and iterative refinement to ensure gain, UGB, phase margin, and output swing meet the load-driving requirements under process and temperature variation.\nThe physical design phase is performed entirely in KLayout, following industry-aligned analog layout practices: matching-aware device placement, common-centroid arrays, dummy structures, guard rings, routing strategies, density compliance, pad-frame integration, and the use of IHP-provided seal-ring and ESD p-cells. Parasitics are extracted using KLayout-PEX (KPEX), and post-layout simulations confirm the impact of capacitor/resistor parasitics on stability and dynamic response, validating the design’s robustness across PVT.\nA key contribution of this work is practical verification: two tape-outs were accepted and fabricated in the IHP Open MPW run of July 2025. To strengthen cross-disciplinary understanding, the authors executed two complete tape-outs, one for a design of NMOS foldedcascode structure and other for PMOS foldedcascode structure, switching roles one serving as design engineer while the other served as layout engineer in the first run, and vice versa in the second. This approach revealed workflow bottlenecks, toolchain strengths, and realistic guidance for analog teams adopting open-source EDA.\nThe results demonstrate that a fully open-source toolchain, combined with an industry-grade SiGe BiCMOS open PDK, can reliably produce manufacturable analog ICs with predictable post-layout performance. This work serves as a practical reference for engineers, researchers, and SMEs evaluating open-source flows for mixed-signal IC development, and provides evidence that democratized, open analog IC design is not only feasible but tape-out proven.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html",
    "href": "content/_sec_introduction.html",
    "title": "2  Introduction",
    "section": "",
    "text": "2.1 Scope of the Thesis\nIn recent years, the open-source hardware ecosystem has matured to a point where advanced analog and mixed-signal integrated circuit (IC) design has become increasingly feasible outside proprietary EDA environments.\nBuilding on this trend, the present work contributes to the preparatory phase of a larger collaborative initiative that aims to strengthen open-source-based chip design methodologies for small and medium-sized enterprises (SMEs), universities, and research institutes.\nUsing the design of an LED driver IC as a demonstrator, the overarching project seeks to identify and close gaps in the open-source design flow and to establish a reproducible, validated toolchain for mixed-signal system design.\nThe long-term objective of the parent project is to extend the open-source IIC-OSIC-TOOLS developed by Prof. Pretl (JKU Linz) with the IHP OpenPDK SG13G2, a 130 nm SiGe BiCMOS process offering analog and RF capabilities suited for power management, sensor, and communication ICs.\nBy integrating the PDK into the IIC-OSIC-TOOLS flow, the project aims to make open-source chip design accessible for SMEs, who have so far been restricted to board-level development due to the prohibitive cost and complexity of commercial EDA ecosystems.\nThis initiative aligns with the global movement toward democratizing IC design, exemplified by the formation of the IEEE SSCS Technical Committee on Open Source Ecosystem (TC-OSE).\nWithin this framework, the present thesis establishes the proof of concept for the analog front-end of the LED driver IC.\nThe work focuses on developing, simulating, and taping-out an operational amplifier (OTA) using the IHP SG13G2 PDK and the IIC-OSIC-TOOLS.\nThe design was submitted to the IHP Open Multi-Project Wafer (MPW) Run in July 2025, demonstrating a complete, fabrication-ready analog layout realized entirely with open-source tools such as Xschem, Ngspice, KLayout, Klayout-PEX, and CACE.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#scope-of-the-thesis",
    "href": "content/_sec_introduction.html#scope-of-the-thesis",
    "title": "2  Introduction",
    "section": "",
    "text": "Technical Milestone\n\n\n\nThe successful tape-out of the OTA represents one of the earliest demonstrations of the SG13G2 OpenPDK using the IIC-OSIC toolchain and serves as a validation of the open-source analog flow.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#motivation-and-challenges",
    "href": "content/_sec_introduction.html#motivation-and-challenges",
    "title": "2  Introduction",
    "section": "2.2 Motivation and Challenges",
    "text": "2.2 Motivation and Challenges\nThe analog subsystem of an LED driver in aircraft cabin lighting must regulate voltages between 18 V and 32 V, ensuring efficiency, low noise, and individual seat controllability.\nSuch power-management circuits are particularly sensitive to layout-dependent parasitic effects, which can degrade performance. Hence, a major emphasis of this work lies in the DRC- and LVS-clean design and its reliability in open-source flows.\n\n\n\n\n\n\nCore Research Focus\n\n\n\nImprovement of PEX precision and post-layout verification within the open-source flow is the central contribution of this thesis and the broader collaborative project.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/_sec_introduction.html#methodological-contributions",
    "href": "content/_sec_introduction.html#methodological-contributions",
    "title": "2  Introduction",
    "section": "2.3 Methodological Contributions",
    "text": "2.3 Methodological Contributions\nBeyond the circuit-level design, this research establishes a validated analog verification workflow under fully open conditions.\nThe complete flow — from schematic capture, device sizing, and layout to LVS, PEX, and post-layout simulation — was developed within the IIC-OSIC-TOOLS environment.\nInsights gained from the OTA design, including device matching, guard-ring implementation, fill density, and PEX consistency, are being integrated into improvements of the toolchain for future mixed-signal designs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "content/_sec_Requirements_AES.html",
    "href": "content/_sec_Requirements_AES.html",
    "title": "3  Requirements",
    "section": "",
    "text": "3.1 Topology Selection:\nA switch-mode LED driver IC needs to be designed to operate within an 18–36 V input range, support high-resolution (16-bit) PWM dimming for at least four RGBW channels with adjustable current control (1–40 mA), integrate protection features (ESD, over/under-voltage, over-temperature), and enable robust data communication with upstream and downstream ICs. The IC must also include an internal oscillator (≥25 MHz), internal generation of data line supply (3–5 VDC), and advanced diagnostics such as LED error detection.\nTo meet the defined performance and protection requirements efficiently, a buck converter topology has been selected for the LED driver IC. This choice is based on the analysis and recommendations from Bernhard Wicht’s 2020 paper Analog Building Blocks for DC-DC Converters, [1] which highlights the buck converter as a suitable and energy-efficient architecture for step-down voltage regulation in integrated power management systems. Given the input voltage range of 18–36 V and the need for tightly regulated current control per channel (1–40 mA), the buck converter enables high efficiency and compact implementation. Its compatibility with mixed-signal integration and the ability to support precise current regulation and fast transient response makes it well aligned with the requirements of our LED driver IC, particularly in ensuring reliable performance across varying input conditions and thermal loads.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Requirements</span>"
    ]
  },
  {
    "objectID": "content/_sec_Requirements_AES.html#block-diagram",
    "href": "content/_sec_Requirements_AES.html#block-diagram",
    "title": "3  Requirements",
    "section": "3.2 Block Diagram",
    "text": "3.2 Block Diagram\n\n\n\n\n\n\nFigure 3.1: Block Diagram\n\n\n\n\n\n\n\n\n\n\nBlock\nFunction\n\n\n\n\nPower Stage Interface\nInductor-Capacitor Buck output stage\n\n\nPWM Generator\nRamp + Comparator\n\n\nError Amplifier\nFeedback loop, V_ref vs V_out\n\n\nCurrent Control\nPer channel analog regulation (DAC + current sink)\n\n\nThermal + Voltage protections\nShutdown to over-temperature, over and under voltages\n\n\nBiasing, reference circuits, reference sources\nBandgap or bias current\n\n\n\n\n\n\n\n[1] B. Wicht, “Analog building blocks of dc-dc converters: Examining fundamental concepts,” IEEE Solid-State Circuits Magazine, vol. 12, no. 3, pp. 42–47, 2020, doi: 10.1109/mssc.2020.3002141.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Requirements</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_design.html",
    "href": "content/_sec_OTA_design.html",
    "title": "4  OTA Design",
    "section": "",
    "text": "4.1 Into the design\nThe focus of our thesis is designing and implementating error amplifier block within the selected buck converter topology using Open Source Tools. This involves developing the block from initial specification and schematic design through to layout, verification (including LVS and PEX), and final tapeout using exclusively open-source tools and IHP-SG13G2 PDK. The goal is to create a high-performance, low-power error amplifier tailored to the requirements of the mixed-signal LED driver IC, ensuring accurate regulation and stability of the control loop. This work will contribute a critical building block to the overall ASIC design while also serving as a case study in open-source analog IC design workflows.\nThe amplifier is tailored to meet the feedback stability and performance specifications of the LED driver system operating within a 5 V output and 18–36 V input range.\nIn the section detailing buck converter control design (especially the voltage-mode control loop), [1] focuses on:\nFinal Take:\nFolded Cascode OTA (see Figure 4.1) is very much aligned with [1] methodology, especially if our focus is on:\nAs shown in the Figure 4.1, \\(M_1\\) and \\(M_2\\) are the input differential pair mosfets with \\(M_5,_6\\) and \\(M_7,_8\\) as their cascoded mosfets.\nThe current mirror constructed out of \\(M_\\mathrm{3,7}\\) and \\(M_\\mathrm{4,8}\\) is a special kind of cascode current mirror for low-voltage operation, also referred to as high-swing cascode current mirror [2]. This type is very often used, as it forces the \\(V_{GS}\\) and \\(V_{DS}\\) of \\(M_{3,4}\\) to be equal, so the current mirror ratio is independent of \\(g_{ds}\\).",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>OTA Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_design.html#into-the-design",
    "href": "content/_sec_OTA_design.html#into-the-design",
    "title": "4  OTA Design",
    "section": "",
    "text": "Cascode Bias Voltage Generation\n\n\n\nIt is critically import for a stable performance across PVT that the bias voltages for the cascode gates are created in a manner that tracks variations with process, temperature, and supply voltage!",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>OTA Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_design.html#sec-gmid-method",
    "href": "content/_sec_OTA_design.html#sec-gmid-method",
    "title": "4  OTA Design",
    "section": "4.2 Sizing using \\(g_{m}\\) over \\(I_d\\) method",
    "text": "4.2 Sizing using \\(g_{m}\\) over \\(I_d\\) method\nIn nanometer CMOS, the MOSFET behavior is much more complex than these simple models. Also, this highly simplified derivations introduce concepts like the threshold voltage or the overdrive voltage, which are interesting from a theoretical viewpoint, but bear little practical use. Modern compact MOSFET models (like the PSP model used in SG13G2) use hundreds of parameters and fairly complex equations to somewhat properly describe MOSFET behavior over a wide range of parameters like width, length and temperature. A modern approach to MOSFET sizing is thus based on the thought to use exactly these MOSFET models, characterize them, put the resulting data into tables and charts, and thus learn about the complex MOSFET behavior and use it for MOSFET sizing.\nThe gm over Id methodology has the huge advantage that it catches MOSFET behavior quite accurately over a wide range of operating conditions, and the curves look very similar for pretty much all CMOS technologies, from micrometer bulk CMOS down to nanometer FinFET devices. Of course the absolute values change, but the method applies universally.\nWe will be using the pygmid tool which is included in IIC-OSIC-TOOLS and is basically a python version of the gm/Id starter kit from Boris Murmann.\nA brief implementation of this method is available here\nFollowing is the python notebook designed for the sizing of Foldedcascode OTA with nmos differential input pair using \\(g_{m}\\) over \\(I_d\\) method.\n\n\n\n\n\n\nOTA Sizing\n\n\n\n\n\nDetailed python code for sizing can be found here",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>OTA Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_design.html#complete-design-and-constant-g_m-biasing-using-current-mirrors",
    "href": "content/_sec_OTA_design.html#complete-design-and-constant-g_m-biasing-using-current-mirrors",
    "title": "4  OTA Design",
    "section": "4.3 Complete Design and constant \\(g_m\\) biasing using current mirrors",
    "text": "4.3 Complete Design and constant \\(g_m\\) biasing using current mirrors\nBased on the sizing procedure in Section 4.2, we are ready with all the \\(W/L\\) ratios and able to design the complete OTA (see Figure 4.2)\n\n\n\n\n\n\nFigure 4.2: OTA design in Xschem\n\n\n\nFind the schematic design here\n\n4.3.1 Discussion of the OTA Design\nWe will now do an analysis of the circuit design of the OTA including all the complications which make this design practical.\n\nFor easier navigation, the device identifier are consistent with the circuit sketch in Figure 4.2.\nSome MOSFET dimensions are rounded to make a better fit in the IC layout. Please also look carefully at \\(W\\), \\(L\\), and \\(\\mathrm{ng}\\). The parameter \\(\\mathrm{ng}\\) defines how the total \\(W\\) of a MOSFET should be split into individual MOSFET fingers with \\(W_\\mathrm{f} = W / \\mathrm{ng}\\). This is done to arrive at a suitably sized MOSFET physical implementation.\nAs you can (hopefully) see the circuit is carefully drawn to ease readability. Important nets are named, text comments state certain properties like nominal voltage levels, bias currents, etc. Current sensing elements are added to directly see the dc currents in the circuit simulation.\nThe bias voltage generation for the cascodes is included as well. The voltage drop for the bottom transistors is developed by properly scaling the MOSFETs in the reference branch. We reduce the \\(W/L\\) ratio to increase the \\(V_{GS}\\) to create a voltage headroom for the bottom MOSFET.\nSensitive bias nodes are buffered with decoupling capacitors. We are using MOSFETs as nonlinear capacitors, which is not an issue in this application, but we value the increased capacitive density. Please note how the MOSFET are connected (some are tied to \\({VDD}\\) while others are tied to \\(V{SS}\\)).",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>OTA Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_design.html#sec-ota-simulation",
    "href": "content/_sec_OTA_design.html#sec-ota-simulation",
    "title": "4  OTA Design",
    "section": "4.4 Simulation of the OTA",
    "text": "4.4 Simulation of the OTA\nNow that circuit is ready we need to test its ac and transient behaviour as well as loop gain using Middlebrook’s method and Tian’s method as mention in Figure 4.3, Figure 4.5, Figure 4.7\n\n\n\n\n\n\nFigure 4.3: AC Analysis Setup\n\n\n\n\n\n\n\n\n\nFigure 4.4: AC Analysis Output\n\n\n\n\n\n\n\n\n\nFigure 4.5: Transient Analysis Setup\n\n\n\n\n\n\n\n\n\nFigure 4.6: Transient Analysis Output\n\n\n\n\n\n\n\n\n\nFigure 4.7: Loop Gain Setup\n\n\n\nThe loop gain analysis yeilds the following plots which clarifies that our specifications such as gain and phase margin are met successfully. See Figure 4.8 and Figure 4.9 The plots include both Middlebrook’s and Tian’s method for loop gain.\n\n\n\n\n\n\nFigure 4.8: MAgnitude middlebrook vs Tian.\n\n\n\n\n\n\n\n\n\nFigure 4.9: Phase middlebrook vs Tian.\n\n\n\n\n\n\n\n[1] B. Wicht, “Analog building blocks of dc-dc converters: Examining fundamental concepts,” IEEE Solid-State Circuits Magazine, vol. 12, no. 3, pp. 42–47, 2020, doi: 10.1109/mssc.2020.3002141.\n\n\n[2] P. G. A. Jespers and B. Murmann, Systematic design of analog CMOS circuits: Using pre-computed lookup tables. Cambridge University Press, 2017.",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>OTA Design</span>"
    ]
  },
  {
    "objectID": "content/_sec_cornersimulations.html",
    "href": "content/_sec_cornersimulations.html",
    "title": "5  Corner Simulations for PVT and Monte-Carlo",
    "section": "",
    "text": "As you have seen in Section 4.4, running simulations by hand is tedious. When we want to check the overall performance, we have to run many simulations over various conditions:\n\nThe supply voltage of the circuit has tolerances, and thus we need to check the performance against this variation.\nThe temperature at which the circuit is operated is likely changing. Also the performance against this has to be verified.\nWhen manufacturing the wafers random variations in various process parameters lead to changed parameters of the integrated circuit components. In order to check for this effect, wafer foundries provide model files which shall cover these manufacturing excursions. Simplified, this leads to a slower or faster MOSFET, and usually NMOS and PMOS are not correlated, so we have the process corners SS, SF, TT, FS, and FF. So far, we have only used the TT models in our simulations.\n\nThe variations listed in the previous list are abbreviated as PVT (process, voltage, temperature) variations. In order to finalize a circuit all combinations of these (plus the variations in operating conditions like input voltage) have to be simulated. As you can imagine, this leads to a huge number of simulations, and simulation results which have to be evaluated for pass/fail.\nThere are two options how to tackle this efficiently:\n\nAs an experienced designer you have a very solid understanding of the circuit, plus based on the analytic equations you can identify which combination of operating conditions will lead to a worst case performance. Thus, you can drastically reduce the number of corners to simulate, and you run them by hand.\nYou are using a framework which highly automates this task of running a plethora of different simulations and evaluating the outcome. These frameworks are called simulation runners.\n\nLuckily, there are open-source versions of simulation runners available, and we will use CACE. CACE is written in Python and allows to setup a datasheet in YAML which defines the simulation problem and the performance parameters to evaluate against which limits. The resulting simulations are then run in parallel and the simulation data is evaluated and summarized in various forms.\nThere is a CACE setup available for our OTA. The datasheet describes the operating conditions and the simulations tasks. For each simulation a testbench template is needed, this one is used for ac simulations, this one is used for noise simulation, and this one is used for transient simulation.\nAfter a successful run, a documentation is automatically generated. The result of a full run of this is presented below:\n\n\n\n\n\n\nCACE Summary for OTA\n\n\n\n\n\nnetlist source: schematic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nTool\nResult\nMin Limit\nMin Value\nTyp Target\nTyp Value\nMax Limit\nMax Value\nStatus\n\n\n\n\nOutput voltage ratio\nngspice\ngain\n0.98 V/V\n0.996 V/V\nany\n0.999 V/V\n1.1 V/V\n1.000 V/V\nPass\n\n\nBandwidth\nngspice\nbw\n1e6 Hz\n5118320.000 Hz\nany\n7827360.000 Hz\nany\n13271000.000 Hz\nPass\n\n\nOutput voltage ratio (MC)\nngspice\ngain_mc\nany\n0.671 V/V\nany\n0.996 V/V\nany\n1.502 V/V\nPass\n\n\nBandwidth (MC)\nngspice\nbw_mc\n1e6 Hz\n1024950.000 Hz\nany\n7454465.000 Hz\nany\n91913200.000 Hz\nPass\n\n\nOutput noise\nngspice\nnoise\nany\n0.069 mV\nany\n0.101 mV\n0.2 mV\n0.134 mV\nPass\n\n\nSettling time\nngspice\ntsettle\nany\n0.259 us\nany\n0.287 us\n1.5 us\n0.320 us\nPass\n\n\n\n\n\n\nAlong with this, all the PVT and MonteCarlo graphs are plotted using python which can be found here\nLet’s take Noise vs Corner for example:\n\n\n\n\nnoise_vs_corner\n\n\n\nThe situation with the design is summarized in Table 5.1.\n\n\n\nTable 5.1: Voltage buffer specification\n\n\n\n\n\nSpecification\nOTA\nUnit\n\n\n\n\nOutput voltage error\n\\(&lt;1\\)\n%\n\n\nTotal output noise (rms)\n\\(&lt;0.15\\)\nmVrms\n\n\nSupply current (as low as possible)\n\\(&lt;14\\)\nµA\n\n\nTurn-on time\n\\(&lt;0.4\\)\nµs\n\n\nExternally provided bias current (nominal)\n\\(12.5\\)\nµA",
    "crumbs": [
      "Circuit Design",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Corner Simulations for PVT and Monte-Carlo</span>"
    ]
  },
  {
    "objectID": "content/_sec_into_layout.html",
    "href": "content/_sec_into_layout.html",
    "title": "6  Introduction to Layout",
    "section": "",
    "text": "6.1 Layout Toolchain: KLayout\nOnce, schematic in Xschem is finished, what we have is only the functional intent of the circuit. At this stage the devices are ideal: transistors have exactly the width and length we assign, wires have zero resistance, and parasitics like source/drain capacitances or coupling between metals are invisible. The layout stage is where this abstraction becomes real silicon geometry. Here, every transistor must be drawn in the technology’s layers, with actual fingers, source/drain contacts, guard rings and no component is ideal anymore.\nFor analog circuits, this step is critical. Small layout choices for example, placing two input devices slightly asymmetrically, or routing one input longer than the other can directly show up as offset voltage or degraded common-mode rejection. In digital design, such effects are often absorbed by logic thresholds, but in analog design they decide whether the OTA meets its simulated gain or not.\nIn other words, schematic defines “what we want”, layout decides “what we actually get”. This chapter focuses on showing how a folded-cascode OTA in IHP-SG13G2 was translated from a verified schematic into a manufacturable layout that still respects matching, symmetry, and parasitic limits.\nFor the layout implementation, we relied on KLayout. It is a free, scriptable editor that is already integrated with the IHP-SG13G2 open-source PDK and provided in the IIC-OSIC toolchain. This makes it possible to perform layout tasks without the need for commercial software.\nAll necessary files such as Design Rule Checks (DRC), LVS comparison setups, and Parameterized cells (PCells) are directly accessible and supported within KLayout. This allows devices to be generated, verified, and extracted in a reproducible way.\nFor further details, see the KLayout website.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introduction to Layout</span>"
    ]
  },
  {
    "objectID": "content/_sec_into_layout.html#layout-toolchain-klayout",
    "href": "content/_sec_into_layout.html#layout-toolchain-klayout",
    "title": "6  Introduction to Layout",
    "section": "",
    "text": "Using KLayout: Docker vs. Source Build\n\n\n\n\n\nOur layout work was carried out using KLayout v0.30.1, provided within the IIC-OSIC Docker image. Since this image is a prebuilt package, some advanced KLayout or Qt features may not function as expected.\nIf KLayout is build from source on your system, most of these limitations disappear, but in that case IHP-SG13G2 technology files and libraries must be manually integrated the into your local setup.\nFor guidance on this process, a useful resource is this Efabless tutorial (second section by Thomas Perry).",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introduction to Layout</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html",
    "href": "content/_sec_OTA_layout.html",
    "title": "7  Device-Level Layout Concepts",
    "section": "",
    "text": "7.1 Matching & Symmetry\nIntegrated circuit layout translates the schematic into physical layers on silicon.\nThe IHP-SG13G2 process provides numerous layers such as active/diffusion regions, poly gates, contacts, multiple metal levels, and passivation. [1].\nEach of these layers plays a role in forming MOSFETs, capacitors, resistors, and interconnects, further layer specific description for the IHP PDK can be found on Layout Rules [1].\nUnlike digital design, where the goal is mainly connectivity, analog layout must ensure matching, symmetry, and parasitic control. This is particularly critical in our folded-cascode OTA, where the differential input pair, current mirrors, and cascode devices dominate the overall gain, offset, and common-mode rejection ratio (CMRR) [[2]][3].\nThe following subsections describe the major device-level layout techniques used in this work, with examples and figures suggested for illustration.\nIn real silicon, device characteristics are never perfectly uniform across the die.\nProcess gradients arise during fabrication due to variations in temperature, pressure, and material distribution. These gradients can be visualized using concepts similar to isobars (lines with constant mechanical pressure) or isotherms (lines with same temperature), where physical properties gradually shift across the wafer surface [3].\nSuch gradients directly affect threshold voltage, mobility, and oxide thickness. As a result, two transistors with identical schematic dimensions may behave differently if placed at different positions on the chip. For analog circuits like OTAs, these mismatches degrade input offset, gain, and common-mode rejection ratio (CMRR).\nTo minimize this, layout must enforce symmetry:\nTogether, these forms of symmetry improve matching the ability of two devices to exhibit nearly identical electrical performance. Accurate matching is critical in the OTA’s input stage, where small imbalances directly appear as input offset voltages.\nFinally, symmetry must extend to the routing. Interconnect lengths, widths, and via stacks must be balanced on both sides of the differential pair. Even with well-matched devices, asymmetric wiring can introduce additional resistance and capacitance, which shows up as systematic offset or degraded bandwidth [2], [3].\nIn our OTA layout, routing symmetry was not only maintained in terms of path length and via balance, but also extended to the choice of metal layers. Long interconnects were assigned to higher metal layers with lower sheet resistance, while short local connections remained on lower metals for compact access.\nThis combination of length balancing, via symmetry, and layer assignment ensured that both differential branches exhibited comparable parasitic resistance and capacitance, preserving matching despite unavoidable topological constraints.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#matching-symmetry",
    "href": "content/_sec_OTA_layout.html#matching-symmetry",
    "title": "7  Device-Level Layout Concepts",
    "section": "",
    "text": "Figure 7.1: Thermal gradients caused by non-uniform heat distributtion across the chip area. Best practice is to place the devices along the same isotherm. (adapted from [3])\n\n\n\n\n\n\n\n\n\nFigure 7.2: Contradictory to above gradient in mechnical stress high gradient area should be avoided such as corners and devices should be placed closer to chip center lines (adapted from [3]).\n\n\n\n\n\nSymmetry around an axis.\nDevices intended to operate as pairs, such as the OTA differential input transistors, are placed symmetrically about a central axis. This ensures that any linear process gradient affects both devices equally, preserving balance in their electrical behavior.\nSymmetry in current flow.\nSymmetry is not only geometrical but also electrical. The orientation of source, drain, and gate terminals is arranged so that current flows through matched devices in identical directions. This prevents systematic mismatches introduced by unequal diffusion edge proximity or channel orientation.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#multi-fingering",
    "href": "content/_sec_OTA_layout.html#multi-fingering",
    "title": "7  Device-Level Layout Concepts",
    "section": "7.2 Multi-Fingering",
    "text": "7.2 Multi-Fingering\nWhen MOSFETs are designed with very wide channel widths, implementing them as a single continuous device introduces several problems. A long, uninterrupted polysilicon gate line introduces significant polysilicon gate resistance, which degrades high-frequency behavior and increases phase delay. At the same time, the enlarged diffusion regions lead to higher source and drain junction capacitances, creating substantial loading on sensitive circuit nodes. Finally, wide monolithic devices suffer in terms of matching: process gradients across the active area are no longer averaged, making these devices more vulnerable to systematic variation and random mismatch effects [2], [3].\nThe solution is multi-fingering: dividing the wide transistor into several narrower, identical fingers that are connected in parallel. This segmentation reduces gate resistance (shorter poly stripes), distributes junction capacitances more evenly, and improves statistical matching by averaging across multiple smaller units.\nIn our OTA, the tail current source required a total width of 8.5 µm. Instead of realizing it as a single device, it was split into four fingers of 2.125 µm each. This segmentation reduced the distributed gate resistance, improved current uniformity, and made gate routing more compact and symmetrical, while maintaining acceptable junction capacitance at the high-impedance tail node. Similarly, majority of transistors were implemented in multi-finger form to balance parasitic capacitances and maintain symmetry across branches.\n\n\n\n\n\n\nFigure 7.3: Represents the tail transistor in our layout with 4 fingers instead of one huge block lead to well matched layout with other transistors and clean routing.\n\n\n\nDespite its benefits, multi-fingering comes with trade-offs:\n- Increased routing overhead, since all fingers must be tied together with well-balanced interconnect.\n- Extra junction perimeters, which can increase total parasitic capacitance if the layout is not compacted carefully.\n- Via placement sensitivity, as each finger requires source/drain contacts and vias; poor via distribution can lead to resistance mismatches or electromigration concerns. Using 2 vias is always reccommended.[3]\nFor this reason, multi-fingering is often combined with other layout strategies.\nDummies are placed at the array edges to shield active fingers, while common-centroid arrangements may be used for further gradient cancellation. This combined approach was applied in our OTA’s diffpair, ensuring both parasitic reduction and high matching fidelity.\n\n\n\n\n\n\nHow to calculate minimum number of fingers\n\n\n\nDetermining the appropriate number of fingers for a wide MOSFET is not arbitrary; it requires balancing several parasitic and physical effects.\nAs excessive fingering increases total diffusion perimeter and further elevating the total source/drain junction capacitance.\nTherefore, selecting the minimum number of fingers that satisfies these electrical and physical constraints is essential for achieving optimal analog performance.\nA rigorous methodology for estimating this minimum finger count considering gate resistance limits, diffusion capacitance contributions, layout symmetry, and manufacturability is presented in Section 5.6: Finger Count Estimation, where the all equations and procedures are discussed in detail.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#dummy-devices",
    "href": "content/_sec_OTA_layout.html#dummy-devices",
    "title": "7  Device-Level Layout Concepts",
    "section": "7.3 Dummy Devices",
    "text": "7.3 Dummy Devices\nEven when multi-fingering is used, the edge fingers of a device array experience different fabrication conditions compared to the inner fingers. At the boundary between active diffusion and isolation (STI), variations in oxide growth, stress, and implant profiles create edge effects that change threshold voltage, carrier mobility, and junction capacitance [2].\nIf left unaddressed, these systematic differences degrade device matching, particularly in sensitive analog structures such as the OTA input pair or current mirrors.\nTo eliminate this, dummy devices are placed at the ends of transistor arrays. They act as sacrificial neighbors, ensuring that all active devices are surrounded by identical environments.\nThis makes the inner devices more uniform, effectively shielding them from edge-related mismatches.[3]\nConnection of dummy devices can vary across design flows:\n- In some methodologies, dummy gates are left floating, since their only role is geometric.\n- In others, dummies are tied to supply rails (AVDD or AVSS) to avoid LVS errors and ensure consistent recognition by verification tools.\nIn our OTA, Dummy devices were placed at the edges of all the MOSFET’s. This ensured that all transistors within the OTA operated in well-matched environments, minimizing systematic offset.\n\n\n\n\n\n\nImportant Implementation Note\n\n\n\n\n\nIn our OTA layout, dummy devices were implemented as complete MOSFETs with their gates explicitly tied to AVDD or AVSS.\nThis was necessary because in KLayout, adding an extra finger with an unconnected gate/source/drain is not recognized as a dummy. LVS then fails due to netlist mismatches.\nTo ensure LVS clean results, we:\n- Added dummy devices explicitly in the schematic.\n- Connected all terminals to valid nets.\n- Replicated the same connections in layout.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#interdigitated-layout",
    "href": "content/_sec_OTA_layout.html#interdigitated-layout",
    "title": "7  Device-Level Layout Concepts",
    "section": "7.4 Interdigitated Layout",
    "text": "7.4 Interdigitated Layout\nWhen two matched transistors are placed adjacent to each other but in separate diffusion regions, each device is exposed to a slightly different portion of the process gradient across the chip. As a result, parameters such as threshold voltage, carrier mobility, and oxide thickness vary between them, leading to a systematic mismatch even though both devices have identical drawn dimensions.\nThe interdigitated layout technique addresses this issue by physically alternating the unit devices of a matched pair or array. Instead of grouping devices as AA–BB, the transistors are arranged in an alternating or mirrored pattern such as ABAB or A–B–B–A, where A and B represent identical unit devices belonging to two matched elements.\nThrough this alternating placement, each device is spatially distributed across the gradient, allowing it to experience regions of both higher and lower process variations. As a result, the local fabrication differences are averaged out across all unit fingers, and the two devices become physically and electrically better matched under real process conditions.\n\n\n\n\n\n\nFigure 7.4: Shows the interdigitated layout pattern “ABBA” (right) of current mirror schematic of NMOS-FETs with current ratio 1:1(left). The “D” gates in layout represent the Dummy transistors.[3]\n\n\n\nThis concept can be visualized by imagining a linear gradient across the x-axis of the die. If one device occupies the left region and the other the right, they sample distinct gradient values. However, when their unit fingers are interleaved, each device occupies multiple local regions along the gradient, resulting in matched average parameters.\nIn practice, interdigitation is most effective for linear process gradients along one direction and is often used for matched transistor pairs, current mirrors, or differential input stages.\nFor two-dimensional gradients or more complex variations, this technique is typically extended using common-centroid placement (discussed in the next section).\nIn the folded cascode OTA, interdigitation was applied to the active loads and bias current mirrors. This layout ensured that each mirrored transistor experienced an equivalent average doping and oxide thickness, resulting in better current matching, symmetrical output swing, and reduced systematic offset in bias generation.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#common-centroid-layout",
    "href": "content/_sec_OTA_layout.html#common-centroid-layout",
    "title": "7  Device-Level Layout Concepts",
    "section": "7.5 Common-Centroid Layout",
    "text": "7.5 Common-Centroid Layout\nWhile interdigitation cancels first-order linear gradients along a single direction, it cannot fully correct for two-dimensional or higher-order variations such as diagonal gradients or wafer-level curvature. For more advanced matching requirements such as in precision current mirrors or differential pairs in high-gain OTAs common-centroid layout is used.\nIn a common-centroid configuration, matched devices are arranged so that their geometric centers, or centroids, coincide. Each device is distributed symmetrically around a central point such that any gradient whether horizontal, vertical, or diagonal affects both devices equally when averaged over their area. This approach effectively cancels first-order gradient components in both axes and reduces second-order effects as well [3].\nConceptually, the centroid layout extends the interdigitated approach into two dimensions. For example, four identical transistors can be arranged symmetrically around a central point in an AB/BA pattern, forming what is effectively a square or cross-shaped configuration.\n\n\n\n\n\n\nFigure 7.5: Illustrates how common centroid configuration can be achieved (right) of current mirror schematic of NMOS-FETs with current ratio 1:1(left). Its clear that devices are extremely symmetrical along X-and Y-axis, however routing always introduces some asymmetry which can be neglected for time being. Here, space is intentionally left between transistors for clear visuals and understanding. The “D” gates in layout represent the Dummy transistors.\n\n\n\nAlthough each individual finger occupies a slightly different position on the chip and therefore a slightly different local environment the geometric center (centroid) of all devices coincides. This ensures that the averaged electrical properties of each device are identical, effectively cancelling first-order process gradients across both axes.\nIn our folded-cascode OTA, the diff pair were laid out using a common-centroid pattern derived from the AB/BA principle. This was essential to maintain current accuracy and minimize systematic gain variation.\nThe layout ensured that matched transistors experienced a balanced environment, even in the presence of lateral thermal gradients or stress gradients from nearby metal density variations.\nRouting Considerations:\nAchieving symmetry in interconnect is as critical as maintaining symmetry in device placement. In principle, identical path lengths, matched metal layers, and mirrored via distributions help ensure that the parasitic resistances and capacitances experienced by paired devices remain equal. However, practical experience reveals that strict geometric symmetry does not always translate into optimal electrical symmetry, especially in multi-metal processes such as IHP-SG13G2.\nA notable observation from our layout work illustrates this point clearly. In most of tech nodes including IHP-sg13g2 lower metal layers (Metal1, Metal2) exhibit higher sheet resistance, they are typically used for short internal routing, while upper metals provide lower resistance and reduced coupling.\nIn an attempt to maximize matching, the initial differential-pair routing was implemented almost entirely on the lowest metal layers (Metal1 and Metal2), with perfectly mirrored path lengths and identical layer usage on both branches. Although geometrically symmetric, this approach resulted in severe performance degradation: the differential pair failed to operate correctly.\nPost-layout analysis revealed that the close proximity of long parallel segments on the same or adjacent lower metal layers introduced excessive lateral and broadside capacitances, overwhelming the high-impedance input nodes and collapsing the expected differential behavior.\nThis led to a revised routing strategy grounded in parasitic-aware symmetry rather than purely geometric symmetry. The final solution employed a combination of Metal1, Metal2, and Metal3, arranged such that the two branches remained electrically matched but did not rely on identical metal layers running in close parallel. Where parallelism was unavoidable, routing was staggered (e.g., \\(Metal_n\\) with \\(Metal_{n+2}\\)) to reduce capacitive coupling.\nThis parasitic-conscious routing produced a substantial improvement in OTA performance, restoring gain and achieving stable differential operation.\nThese findings highlight that in precision analog layout, symmetry must be interpreted electrically, not only geometrically. Effective matching requires an awareness of sheet-resistance gradients, metal-layer coupling, and the spatial distribution of parasitics.\nMeticulous routing decisions layer staggering, spacing, orthogonality, and controlled via placement often determine whether a differential structure performs ideally or fails entirely.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_layout.html#finger-count-estimation-minimum-number-of-fingers",
    "href": "content/_sec_OTA_layout.html#finger-count-estimation-minimum-number-of-fingers",
    "title": "7  Device-Level Layout Concepts",
    "section": "7.6 Finger Count Estimation (Minimum Number of Fingers)",
    "text": "7.6 Finger Count Estimation (Minimum Number of Fingers)\nThis section establishes a systematic method for estimating the minimum number of fingers \\(N_f\\) required for a wide MOSFET such that\n(i) the distributed gate resistance remains below acceptable limits, and\n(ii) the junction capacitances introduced by segmentation do not dominate the node dynamics.\nThe methodology follows the classical treatment of gate resistance, thermal/gate noise, and diffusion capacitance scaling described in Razavi’s Design of Analog CMOS Integrated Circuits and related literature.\nFor a device with total drawn width \\(W_{tot}\\) and channel length L, splitting the device into \\(N_f\\) identical fingers results in an effective per-finger width\n\\[\nW_f = \\frac{W_{\\text{tot}}}{N_f}.\n\\]\nSelecting \\(N_f\\) is therefore an exercise in determining how narrow each finger can be made before device performance becomes degraded by source drain capacitence, or minimum-geometry constraints.\nThe following design principles guide the estimation procedure:\n\n7.6.1 Gate Resistance Requirement (Low-Noise Criterion)\nAs a practical thumb rule used in low-noise analog design:\n\nEach finger width \\(W_f\\) must be chosen such that the gate resistance of that finger is less than the inverse transconductance \\(1/g_m\\) associated with that finger.\nFor high-performance or low-noise applications, the gate resistance should preferably be in the range of\n\\[\nR_g &lt; \\frac{1}{5 g_m} \\quad \\text{to} \\quad R_g &lt; \\frac{1}{10 g_m}\n\\]\n\nThis condition ensures that the gate thermal noise contribution remains significantly below the channel thermal noise, preventing degradation of input-referred noise or gain.[4]\nBasically, we compare the channel thermal noise with the gate-resistance thermal noise, and we solve to get the value of \\(N_f\\) ensuring that gate noise remains well below channel noise.\nChannel noise:\n\\[\n\\overline{v_{n,\\text{ch}}^2} = \\frac{4 k T\\, \\gamma}{g_m}\n\\]\nGate-resistance noise:\n\\[\n\\overline{v_{n,\\text{g}}^2} = \\frac{4 k T R_{sheet} W}{3 L N_f^2}\n\\]\nwhere,\n\nk is Boltzmann’s constant,\nT is the absolute temperature,\n\\(\\gamma\\) is the noise factor\n\\(g_m\\), W & L are the transconductance, width and length of the device.\n\nIn our application, Channel noise is 5 times that of Gate-resistance noise.\n\n\n7.6.2 Noise Model Adjustment Based on Channel Length\nThe optimization also depends on the noise coefficient \\(\\gamma\\) in the MOSFET thermal noise model. The correct value of \\(\\gamma\\) depends on the channel length:\n\nIf \\(L &lt; 3*L_{min}\\), then \\(\\gamma = 1\\)\n\notherwise, \\(\\gamma = \\frac{2}{3}\\)\n\nBecause shorter-channel devices exhibit stronger velocity saturation and increased thermal noise.\n\n\n7.6.3 Minimum Geometry Constraint\nThe number of fingers must also satisfy:\n\\[\n\\frac{W_{\\text{tot}}}{N_f} &gt; L_{\\min},\n\\]\nbecause excessively narrow fingers approach the minimum manufacturable width and exhibit strong proximity effects, increased mismatch, and higher perimeter capacitance.[5] For the IHP-SG13G2 130-nm process used here, as the name suggests the minimum channel length is:\n\\[\nL_{\\min} = 0.13\\,\\mu\\text{m}.\n\\]\nThis constraint prevents unrealistic fingering.\n\n\n7.6.4 Even Number of Fingers (Practical Layout Consideration)\nAlthough electrically permissible, odd-valued finger counts typically complicate routing and disrupt symmetry. Although in fewer cases odd numbered fingers are used as well.\nBut, a practical recommendation particularly in differential or current-mirror structures is:\nChoose the minimum even number of fingers \\(N_f\\) that satisfies the electrical and geometrical constraints. Even segmentation simplifies mirrored routing, centroid or interdigitated arrangements, and guard ring alignment.\n\n\n\n\n\n\nNumber of fingers Calculation using Python Script\n\n\n\n\n\nTo support the design methodology described above, a dedicated Python script has been developed to automatically compute the minimum number of fingers required for any given MOSFET width.\nThe script implements the thumb-rule constraints introduced above. By providing required parameters, the script outputs the minimum feasible even-valued \\(N_f\\) that satisfies all electrical constraints.\nThe script can be found in Appendix C.\n\n\n\n\n\n\n\n[1] I. PDK, “SG13G2 IHP open source layout rules,” Leibniz Institute for High Performance Microelectronics, Design Reference, Dec. 2024.\n\n\n[2] R. J. Baker, CMOS: Circuit design, layout, and simulation, 3rd ed. Wiley-IEEE Press, 2010, p. 1208. doi: 10.1002/9780470891179.\n\n\n[3] J. Lienig and J. Scheible, Fundamentals of layout design for electronic circuits. Springer International Publishing, 2020. doi: 10.1007/978-3-030-39284-0.\n\n\n[4] B. Razavi, Design of analog CMOS integrated circuits. McGraw-Hill, 2011.\n\n\n[5] B. Razavi, Design of analog CMOS integrated circuits. McGraw-Hill, 2001.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Device-Level Layout Concepts</span>"
    ]
  },
  {
    "objectID": "content/_sec_DRC.html",
    "href": "content/_sec_DRC.html",
    "title": "8  Design Rule Checking (DRC)",
    "section": "",
    "text": "8.1 Fundamentals of DRC\nThe transition from an electrical schematic to a manufacturable integrated circuit relies on the integrity of the layout, which represents the true physical interface between design and fabrication. While schematic-level verification ensures functional correctness and circuit performance, it is the layout that determines whether the circuit can be fabricated reliably within the limits of the chosen process.\nTo formalize and automate this verification, the semiconductor industry have Design Rule Checking (DRC) a systematic comparison of the layout geometry against a set of process-specific constraints provided by the foundry or technology provider (in our case IHP-PDK Authors).\nDesign Rule Checking is a geometric verification step that ensures a layout adheres to the minimum/maximum feature sizes, spacings, enclosures, and overlaps defined by the fabrication process.\nEach layer in a modern BiCMOS process (e.g. diffusion, polysilicon, metal interconnects, and vias) is subject to numerous rules derived from the physical limitations of photolithography, etching, and deposition steps.\nViolating these constraints can lead to a spectrum of manufacturing defects: short-circuits due to over-etching, open connections caused by lithographic line thinning, or parametric variations resulting from disuniform film growth.\nThus, DRC forms the first line of defense against non-manufacturable or yield-critical layouts.\nThe design rules themselves originate from process specifications. Foundries experimentally determine the tolerances of their technology through test structures that measure lithographic resolution, etch bias, and alignment accuracy between layers. From these experiments, statistical margins are extracted and translated into deterministic layout constraints expressed as rules such as minimum Active width = 0.15 µm or minimum spacing between Metal1 lines = 0.18 µm. [1] As discussed in [2], these rules balance manufacturability with design density: tighter rules enable compact designs but raise the risk of yield loss, while relaxed rules increase process robustness at the expense of silicon area.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Design Rule Checking (DRC)</span>"
    ]
  },
  {
    "objectID": "content/_sec_DRC.html#technology-dependence-and-process-node",
    "href": "content/_sec_DRC.html#technology-dependence-and-process-node",
    "title": "8  Design Rule Checking (DRC)",
    "section": "8.2 Technology Dependence and Process Node",
    "text": "8.2 Technology Dependence and Process Node\nEvery technology node for instance, 130 nm, 65 nm, or 28 nm defines its own set of DRC parameters. These parameters evolve with advances in lithographic precision, material systems, and transistor architecture. At older nodes such as 0.35 µm or 0.25 µm, DRC rules mainly governed planar dimensions and spacing; however, in sub-100 nm processes, additional considerations such as antennas, stress effects, and metal density gradients are incorporated. Consequently, the complexity of DRC rules increases exponentially as the process geometry scales down.[3]\nThe Process Design Kit (PDK) serves as the bridge between the foundry and the design environment.\nIt encapsulates all technology-specific information design rules, layer definitions, device models, parasitic extraction parameters, and layout-Vs-schematic (LVS) configurations into a single framework usable by EDA tools.\nThe DRC deck, which is a formalized file (often written in languages such as SVRF or Python-based scripts for tools like KLayout), encodes these geometric constraints in machine-readable form. When the layout is processed through the DRC engine, each polygon and layer is algorithmically compared against the rule database to identify violations.\nIn the case of the IHP SG13G2 130 nm BiCMOS process, used throughout this work, the IHP-PDK provides a comprehensive DRC rule set defining all critical geometrical limits from diffusion-to-diffusion spacing and via enclosures to hierarchical density checks of upper metal layers, [1]. The IHP-PDK also supplies detailed technology definition files that can be manually integrated into layout tools such as KLayout. However, since the IHP-PDK is part of the IIC-OSIC open-source toolchain, these technology files and rule decks are already pre-configured within the provided Docker image, offering an optimized and reproducible setup for DRC verification.\nIn addition, the PDK documentation includes a complete layer table defining all process layers, along with descriptions of forbidden layers reserved for internal fabrication use, grid rules, and the full list of DRC constraints illustrations. This document has served as the primary reference for understanding the process and implementing all layout structures in this work. Hence, even within an open-source environment, the design remains foundry-compliant, physically realizable, and fully aligned with the manufacturing specifications of the SG13G2 process.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Design Rule Checking (DRC)</span>"
    ]
  },
  {
    "objectID": "content/_sec_DRC.html#importance-in-the-design-flow",
    "href": "content/_sec_DRC.html#importance-in-the-design-flow",
    "title": "8  Design Rule Checking (DRC)",
    "section": "8.3 Importance in the Design Flow",
    "text": "8.3 Importance in the Design Flow\nDRC plays a pivotal role in ensuring that the layout is not only electrically correct but physically manufacturable.\nAs mentioned before, an unverified layout might pass all functional and electrical simulations yet still fail in fabrication because certain features violate lithographic limits or introduce yield-limiting defects. Typical examples include insufficient metal spacing leading to shorts, or inadequate enclosure of contacts resulting in open circuits after etching.\nBy enforcing DRC compliance before tape-out, the designer ensures that the design adheres to the design-for-manufacturability (DFM) principles required for reproducible production.\nFurthermore, DRC compliance is not merely a binary condition of “pass or fail.” It also acts as a metric of process awareness: a DRC-clean layout demonstrates the designer’s adherence to technology constraints and reflects a realistic understanding of fabrication tolerances. In professional design flows, foundries refuse to fabricate any layout that fails DRC, as doing so would waste mask costs and process time.\nTherefore, DRC stands as the final checkpoint between design creativity and physical implementation a gate that ensures the logical intent of the schematic can manifest in silicon without violation of the underlying physics.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Design Rule Checking (DRC)</span>"
    ]
  },
  {
    "objectID": "content/_sec_DRC.html#practical-implementation-of-design-rule-checking",
    "href": "content/_sec_DRC.html#practical-implementation-of-design-rule-checking",
    "title": "8  Design Rule Checking (DRC)",
    "section": "8.4 Practical Implementation of Design Rule Checking",
    "text": "8.4 Practical Implementation of Design Rule Checking\nAs discussed in earlier chapters, the layout is the sole design entity that directly communicates with fabrication. Neither schematic diagrams nor behavioral models ever reach the foundry only the geometric database (typically in GDSII or OASIS format) generated from the layout is delivered for mask generation and processing.\nIn this sense, Design Rule Checking (DRC) serves as the mechanism through which the language of design is translated into the language of manufacturing. It guarantees that every transistor, interconnect, and via is drawn within the lithographic and etching tolerances established by the process technology. This alignment between layout geometry and process capability is essential to achieving both functional yield and long-term device reliability.\nTo borrow the phrasing of [3], “a perfect schematic means nothing without a correct layout.”\nDRC ensures that this correctness is quantifiable and verifiable it enforces the discipline that transforms circuit theory into a physically reproducible artifact, one capable of moving confidently from layout database to wafer fabrication.\nIn this work, all DRC verification was performed using KLayout as part of the IIC-OSIC open-source toolchain, which integrates the IHP SG13G2 130 nm BiCMOS process. The PDK provides complete DRC rule decks in the form of Python-based macros that systematically check every process layer and layer combination diffusion overlaps, via enclosures, contact spacings, metal width and density requirements, and top-metal clearance to the passivation opening.\nThe DRC engine performs a hierarchical scan of the layout, flags any violations, and displays annotated markers directly within the KLayout interface for review. Each violation encountered during the layout phase was analyzed and corrected at either the device or routing level until the design achieved a fully DRC-clean status. This verified layout therefore not only satisfies the intended schematic connectivity but also conforms to every physical constraint required for successful fabrication. Through this process, DRC validation in KLayout establishes the final and most critical bridge between the abstract world of circuit design and the tangible reality of silicon manufacturing where compliance with foundry rules ensures that what is drawn can, indeed, be built.\n\n8.4.1 Types of DRC Scripts in the IHP SG13G2 Process\nThe IHP SG13G2 PDK provides two distinct DRC scripts, each corresponding to a specific level of design compliance and verification rigor. These scripts are referred to as sg13g2_minimal and sg13g2_maximal rule decks. Both are written as Python macros configured within the KLayout environment and can be executed directly from the Macros Development interface.\n\nThe sg13_g2_minimal DRC deck enforces the standard design rules of the process: These rules define the mandatory fabrication constraints that must be satisfied to ensure the layout is physically manufacturable. Violations of these checks typically indicate errors that could prevent successful chip production or cause fatal defects in the fabricated devices. Examples include insufficient metal spacing, missing via enclosures, or incorrect layer overlaps. List of minimal rules can be found here.\nThe sg13_g2_maximal DRC deck, in contrast, applies the recommended design rules: These rules contain both mandatory fabrication constraints and non-mandatory therefore are intended to improve overall manufacturability, process reliability, and yield consistency. They provide design hints to minimize parametric variability, such as improving parasitics, preventing latch-ups, or avoiding angles that can introduce stress points during fabrication. While designs that only pass the minimal check are still fabricable, running the sg13_g2_maximal script ensures the layout adheres to best practices for long-term robustness and high-yield performance. List for maximal rules can be found here.\n\n\n\n8.4.2 Performing DRC in KLayout\nAs mentioned in the Known Issues section, DRC cannot be executed in KLayout solely by relying on direct tools or commands. Instead, a specific workflow must be followed. Within the Macros Development interface of KLayout, there is a dedicated DRC section that lists all available rule scripts for the selected technology. To perform DRC, the user must select the desired rule deck either sg13_g2_minimal or sg13_g2_maximal and then execute the corresponding script.\n\n\n\n\n\n\nFigure 8.1: Macro Development interface with DRC Results in Console\n\n\n\nOnce the check is complete, the list of errors appears in the output console below the editor window. Unfortunately, due to current tool limitations, KLayout does not automatically generate a separate DRC report file. This means that the error list cannot be reloaded, filtered, or revisited directly within the tool after the session ends. Furthermore, some Qt-based interactive functions (intended to automatically highlight or open error markers) are not fully supported within the Docker image of the IIC-OSIC toolchain.\nTo address this limitation, a custom Python script was developed in this work to automate the error-handling process. The script parses the raw DRC output copied from the KLayout console and filters the messages to produce a clean, structured list of all raised violations that require manual correction. This greatly simplifies the debugging workflow by identifying unique errors and mapping them to their respective layer categories.\n\n\n8.4.3 DRC Automation Script\nThis is the automation script used for processing DRC results:\n\n\n\n\n\n\nScript\n\n\n\n\n\n\nDRC Errors Check\nThis script gives 2 functions: 1st needs the the errors copied from KLayout to be pasted in drc_log function inside script and than run the script. It can be tidious to change script again and again. Therefore, not recommended.\nFor 2nd function just run the script and paste your errors copied from KLayout in the terminal and press enter and DONE. By default, script uses this function.\n\n# 2nd Funtion\n\ndef parse_drc_errors_new():\n    print(\" Paste your DRC error log below. Press Enter twice to finish:\")\n    \n    # Collect multiline input\n    lines = []\n    while True:\n        line = input()\n        if line.strip() == \"\":\n            break\n        lines.append(line)\n    \n    print(\"\\n⚠️ Rules with errors :\")\n    i=0\n    for line in lines:\n        if \"error(s)\" in line:\n            try:\n                rule, error_text = line.split(\":\")\n                error_count = int(error_text.strip().split()[0])\n                if error_count &gt;= 1:\n                    print(f\"{rule.strip()}: {error_count} error(s)\")\n                    i=1\n\n            except ValueError:\n                continue\n    \n    if i==0:\n        print(\"Congrats! No error\")\n\n\n# Run the parser\nparse_drc_errors_new()\n\n\n\n\n\nTo use the script, simply copy the DRC console output from KLayout, paste it into the terminal running the Python program, and the script will generate a concise summary of the errors that remain to be corrected manually in the layout.\n\n\n\n\n\n\nPro Tip Run DRC Early and Often\n\n\n\nIt is strongly recommended to run DRC checks after every 5–6 layout modifications, even for small routing or placement changes. This practice prevents the accumulation of undetected violations that can take hours to debug later. Running DRC frequently not only saves significant time but also prevents accidental geometry overlaps or spacing errors that could compromise the layout structure and require extensive rework.\n\n\n\n\n\n\n[1] I. PDK, “SG13G2 IHP open source layout rules,” Leibniz Institute for High Performance Microelectronics, Design Reference, Dec. 2024.\n\n\n[2] J. Lienig and J. Scheible, Fundamentals of layout design for electronic circuits. Springer International Publishing, 2020. doi: 10.1007/978-3-030-39284-0.\n\n\n[3] R. J. Baker, CMOS: Circuit design, layout, and simulation, 3rd ed. Wiley-IEEE Press, 2010, p. 1208. doi: 10.1002/9780470891179.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Design Rule Checking (DRC)</span>"
    ]
  },
  {
    "objectID": "content/_sec_LVS.html",
    "href": "content/_sec_LVS.html",
    "title": "9  Layout Vs Schematic (LVS)",
    "section": "",
    "text": "9.1 Fundamentals of LVS\nAfter a layout has been verified for physical manufacturability through Design Rule Checking (DRC), the next essential step is to confirm its electrical correctness with respect to the original schematic. This verification step is known as Layout Vs Schematic (LVS). Whereas DRC ensures that the physical geometry can be fabricated, LVS ensures that the fabricated geometry will function as intended by the circuit design. Together, DRC and LVS form the core of the physical verification process that bridges the logical and geometric domains of IC design.\nLayout Vs Schematic comparison is a netlist-based verification process. It compares the electrical connectivity extracted from the physical layout with that defined in the schematic. During LVS, the tool first performs netlist extraction from the layout (parsing all transistors, polygons, capacitors, and interconnects), and then compares this extracted netlist against the schematic netlist. The goal is to verify that both represent the same electrical circuit that is, the same devices, same connections, and identical hierarchy.\nTypical checks performed during LVS include:\n- Device recognition: confirming that every transistor or passive component in the layout corresponds to a schematic element.\n- Pin and net matching: ensuring all connections and signal names align between the two domains.\n- Parameter equivalence: verifying that critical parameters such as transistor width, length, and multiplicity match (number of fingers).\nIf all devices and nets correspond correctly, the design is said to be LVS clean. Otherwise, the LVS report lists mismatches that must be corrected before fabrication.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Layout Vs Schematic (LVS)</span>"
    ]
  },
  {
    "objectID": "content/_sec_LVS.html#importance-in-the-design-flow",
    "href": "content/_sec_LVS.html#importance-in-the-design-flow",
    "title": "9  Layout Vs Schematic (LVS)",
    "section": "9.2 Importance in the Design Flow",
    "text": "9.2 Importance in the Design Flow\nWhile DRC ensures how a design can be fabricated, LVS ensures what will be fabricated. Even a DRC-clean layout can fail to perform correctly if a wire is connected to the wrong node, a transistor terminal is swapped, or a device is missing. Such errors may lead to functional failure, excessive power consumption, or biasing issues that are difficult to detect without LVS.\nTherefore, LVS verification is critical before tape-out because it confirms the topological equivalence between the intended circuit (schematic) and its physical realization (layout).\nIt ensures that all devices, interconnects, and terminals have been represented faithfully, safeguarding against layout-level errors that could otherwise result in costly re-fabrications.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Layout Vs Schematic (LVS)</span>"
    ]
  },
  {
    "objectID": "content/_sec_LVS.html#practical-implementation",
    "href": "content/_sec_LVS.html#practical-implementation",
    "title": "9  Layout Vs Schematic (LVS)",
    "section": "9.3 Practical Implementation",
    "text": "9.3 Practical Implementation\nIn this work, LVS verification was carried out using KLayout in combination with the IHP SG13G2 PDK inside the IIC-OSIC Docker environment.\nHowever, due to the known limitation that Qt-based LVS functions do not operate within the Dockerized KLayout interface, LVS must be performed externally in the Docker terminal using a Python script provided by the IHP PDK.\n\n\n\n\n\n\nLVS Script\n\n\n\nThe LVS verification script provided with the IHP SG13G2 PDK can be found at:\n/foss/pdks/ihp-sg13g2/libs.tech/klayout/tech/lvs/\nThe main Python file, run_lvs.py, executes the complete LVS procedure.\n\n\nThis LVS script automates the comparison between the schematic netlist and the layout. To execute it, the user provides three key inputs:\n\nThe schematic netlist (in SPICE format, generated from schematic in Xschem)\n\nThe layout GDSII file (the physical design)\n\nThe output directory for output file publication\n\nOnce executed, the script performs layout netlist extraction, mapping, and comparison against the schematic. It then produces several output files, typically including:\n\n.lvsdb : the LVS database containing the extracted and compared netlists with in-depth details\n.cir : the extracted SPICE-format netlist from the layout containing circuit description\n.log : the report of information such as name of files, tool version and error if encountered\n\n\n\n\n\n\n\nImportant Naming Consistency\n\n\n\nFor LVS to run successfully, the schematic name, GDS file name, SPICE netlist name, and the top-cell name inside the GDS must all be identical.\nIf any of these names differ, the Python script will terminate with an unexpected error because it cannot match the top-level hierarchy between schematic and layout.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Layout Vs Schematic (LVS)</span>"
    ]
  },
  {
    "objectID": "content/_sec_LVS.html#interpreting-and-visualizing-lvs-results-in-klayout",
    "href": "content/_sec_LVS.html#interpreting-and-visualizing-lvs-results-in-klayout",
    "title": "9  Layout Vs Schematic (LVS)",
    "section": "9.4 Interpreting and Visualizing LVS Results in KLayout",
    "text": "9.4 Interpreting and Visualizing LVS Results in KLayout\nAfter running the LVS script in the terminal, the generated .lvsdb file can be opened in KLayout for detailed inspection and mapping. To do this, open the corresponding GDS layout in KLayout, then navigate to:\n\nTools → Netlist Browser\n\nThis opens the Netlist Browser catalog window. Within this interface, load the .lvsdb file generated by the script. When the .lvsdb file is opened in the Netlist Database Browser within KLayout, a catalog window appears with four main tabs - Netlist, Schematic, Cross Reference, and Log. The Cross Reference tab displays a side-by-side comparison between the layout and reference schematic, listing all pins, nets, and devices in both domains. Matched elements are shown in green, indicating full correspondence between schematic and layout, as illustrated in Figure below (example: analog_inverter).\n\n\n\n\n\n\nFigure 9.1: Netlist Browser to view LVSDB files and trace nets\n\n\n\nIf mismatches occur, the differences are highlighted in red, showing missing devices, incorrect connections, or parameter discrepancies. These issues are further detailed in the Log tab, which provides textual summary of each error and its location in the design. This visualization enables efficient debugging by allowing the designer to inspect each net and device interactively, ensuring complete electrical equivalence before declaring the layout LVS-clean.\nKlayout also provides powerful tracing functionality, allowing designers to visually select and highlight individual devices or nets within the layout to locate mismatches precisely.\nThis interactive feedback significantly accelerates debugging and helps ensure that every element is electrically connected as intended.\nIn summary, LVS is the final and most critical step in confirming that a verified, DRC-clean layout is also electrically identical to its schematic representation. By performing LVS through the IHP-provided Python script and analyzing results within KLayout, the design achieves both physical and electrical closure.\nThe successful completion of this step certifies that the layout accurately implements the intended circuit topology, allowing it to proceed confidently toward parasitic extraction and post-layout simulation, and ultimately, fabrication.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Layout Vs Schematic (LVS)</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html",
    "href": "content/_sec_parasitics_prevention.html",
    "title": "10  Parasitics and Prevention",
    "section": "",
    "text": "10.1 Why Analog Suffers More from Parasitics\nEven though a layout is DRC- and LVS-clean but can still fail in silicon if parasitics and noise coupling are ignored.\nThis chapter formalizes the main parasitic mechanisms relevant to analog ICs, outlines why analog is more vulnerable than digital, and documents the concrete prevention measures implemented in our design. The discussion follows the physical reasoning and best-practice guidance in [1] (Ch. 7), adapted to the SG13G2 context.\nDigital logic tolerates substantial RC and substrate coupling because functionality is determined by logic thresholds and noise margins. By contrast, analog circuits encode information in amplitude, phase, and continuous bias conditions. Small parasitic shifts in device parameters or interconnect coupling directly effects gain, offset, bandwidth, and noise.\nKey vulnerabilities arise because analog circuits operate on continuous voltage and current levels, where even small parasitic interactions can shift the operating point or distort the signal. 1. High-impedance nodes, such as the inputs of operational transconductance amplifiers (OTAs), are particularly sensitive because they cannot source or sink significant current. Any parasitic capacitance whether from junction diffusion, metal-to-substrate coupling, or fringe fields from nearby interconnects directly loads these nodes. This loading introduces unwanted poles, reduces input resistance, and increases thermal noise coupling. In precision amplifiers, such parasitic capacitances can also create signal-dependent charge storage, causing distortion or phase lag at higher frequencies.\nConsequently, the layout must be arranged to minimize parasitic capacitance at high-impedance nodes, isolate bias networks from noisy regions, and maintain compact, symmetrical feedback routing to preserve loop stability. Therefore, parasitics must be anticipated and shaped not merely checked during layout.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#why-analog-suffers-more-from-parasitics",
    "href": "content/_sec_parasitics_prevention.html#why-analog-suffers-more-from-parasitics",
    "title": "10  Parasitics and Prevention",
    "section": "",
    "text": "Bias networks and current mirrors are another vulnerable class. These circuits rely on exact matching of device characteristics and stable well or substrate potentials to maintain bias accuracy. Substrate noise or potential fluctuations, often injected from digital switching activity or supply ripple, modulate the body voltage of transistors. This alters their threshold voltage and transconductance (\\(g_m\\)), leading to current imbalance, gain drift, and degraded common-mode rejection. In deep-submicron processes with thin oxides and shallow wells, such coupling becomes even more significant.\nFeedback paths in analog systems particularly those forming loops for gain control, regulation, or filtering are strongly influenced by parasitic-induced poles and zeros. Capacitances at feedback nodes or unintended inductive loops in routing can introduce additional frequency-dependent elements into the loop transfer function. These parasitics may reduce phase margin, cause peaking in the frequency response, or even lead to oscillations if uncompensated.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#interconnect-and-device-level-parasitics",
    "href": "content/_sec_parasitics_prevention.html#interconnect-and-device-level-parasitics",
    "title": "10  Parasitics and Prevention",
    "section": "10.2 Interconnect and Device-Level Parasitics",
    "text": "10.2 Interconnect and Device-Level Parasitics\n\n10.2.1 Metal and Coupling Capacitances\nParallel conductors form inter-wire capacitances; long, co-planar runs also couple substrate noise through capacitance to ground.\nIn our layout, we avoid long same-layer parallel routing on sensitive nets. Where proximity is unavoidable, we prefer layer staggering (e.g., route one net on \\(M_n\\) and the other on \\(M_{n+2}\\)), maintain generous spacing, and, when beneficial, add symmetric ground shields. Orthogonal routing between adjacent layers (Manhattan style) further reduces broadside coupling [1].\n\n\n10.2.2 Via and Contact Parasitics\nVias introduce series resistance and small fringing capacitances; unbalanced via stacks can create gain/offset asymmetry. We use redundant via arrays on low-impedance and high-current paths, keep via symmetry across matched branches, and avoid unnecessary layer hops on high-impedance nodes. This also improves electromigration margins.\n\n\n10.2.3 Junction/Overlap Capacitances\nSource/drain junction areas and perimeters add capacitance that loads high-impedance nodes and shifts poles.\nWe mitigate this by multi-fingering large devices (controlling diffusion area/perimeter) and by dummy fingers to regularize edge effects, as detailed earlier. Device segmentation is paired with balanced routing and via symmetry to preserve matching.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#critical-parasitics-mechanisms-and-mitigation-strategies",
    "href": "content/_sec_parasitics_prevention.html#critical-parasitics-mechanisms-and-mitigation-strategies",
    "title": "10  Parasitics and Prevention",
    "section": "10.3 Critical Parasitics Mechanisms and Mitigation Strategies",
    "text": "10.3 Critical Parasitics Mechanisms and Mitigation Strategies\nAs discussed above, the physical behavior of the silicon can be compromised by secondary effects. These parasitic mechanisms though invisible in schematic design can severely degrade performance or even render an integrated circuit non-functional.\nThe following subsections discuss the most relevant effects for analog circuits and the preventive measures applied in this work.\n\n10.3.1 Latch-Up\nLatch-up is a destructive parasitic phenomenon that occurs primarily in bulk CMOS and BiCMOS technologies.\nWithin the substrate and well structure, every pair of adjacent p–n junctions inherently forms parasitic bipolar transistors (pnp and npn).\nWhen certain layout geometries or biasing conditions bring these devices into proximity, they can create an unintended silicon-controlled rectifier (SCR) path between the power rails (AVDD and AVSS).\nA transient event such as an electrostatic discharge, substrate noise spike, or voltage overshoot can trigger the SCR, producing a low-impedance short between supply and ground.\nOnce triggered, the latch-up state sustains itself through regenerative feedback, often leading to local thermal runaway and irreversible damage.\nPrevention:\nLatch-up prevention requires breaking the feedback path and lowering substrate resistance.\nThis is achieved by surrounding all active devices with dense guard rings and inserting well and substrate contacts at regular intervals to provide low-resistance current return paths.\nAdequate spacing between n-wells and p-wells reduces parasitic coupling between complementary transistors.\nFor highly sensitive analog blocks, the deep-N-well (isolation well) option provided in the SG13G2 process was employed. This isolation ensures that the substrate region of the analog core is electrically separated from neighboring digital or I/O structures, effectively suppressing latch-up initiation.\nAdditionally, I/O pads and high-swing nodes are placed away from precision analog circuits to minimize injection of transient substrate currents [1].\n\n\n10.3.2 Antenna Effect\nDuring etching and deposition steps in fabrication, unconnected metal or polysilicon features can act as charge-collecting antennas.\nIf a long interconnect is connected to a transistor gate but not yet to a diffusion region, the charge accumulated on the metal surface can discharge through the thin gate oxide once the diffusion is formed.\nThis discharge can permanently damage or weaken the gate dielectric, leading to gate leakage or early breakdown.\nThe risk increases with larger metal area and thinner gate oxides, making advanced nodes and precision analog devices particularly susceptible.\nPrevention:\nTo prevent this, metal hopping is applied routing is divided into shorter segments by inserting vias to higher or lower metal layers, thus reducing the effective exposed area.\nIn this work, metal segmentation were used for nets identified by the SG13G2 PDK’s antenna check script as having potential plasma-induced charging risk.\n\n\n10.3.3 Interconnecting Vias (Reliability and Noise)\nVias are the vertical interconnects that connect one metal layer to another. Each via has a finite resistance and current-carrying limit.\nIf a single via is forced to conduct large currents, it experiences localized heating and electromigration, which can lead to open circuits or resistance drift over time. Furthermore, any asymmetry in via count or placement between matched branches creates mismatch in series resistance, leading to offset in analog differentials or current mirrors.\nVias also contribute small fringing capacitances, and an uneven via distribution can slightly distort signal paths, particularly at high frequency.\nPrevention:\nTo enhance both reliability and symmetry, we employ redundant via arrays multiple vias placed in parallel to reduce resistance and distribute current density evenly. These are used especially on low-impedance and high-current paths such as power rails, bias lines, and OTA output nodes.\nIn matched differential structures, via symmetry is strictly maintained, meaning identical via count, shape, and placement on both branches. This guarantees balanced parasitic resistance and capacitance, preventing differential offset.\nThese measures collectively improve electromigration margins, ensuring the long-term reliability of the metal interconnect network.\n\n\n10.3.4 Charge Injection and Gate Coupling\nCharge injection refers to the unintended transfer of charge from a switching device’s channel or overlap capacitances into adjacent high-impedance nodes. When a MOSFET gate or drain experiences a fast voltage transition, the associated capacitances (\\(C_{gd}\\), \\(C_{gs}\\), and junction capacitances) couple a portion of the transient charge into nearby sensitive nodes.\nIn analog amplifiers or sampling circuits, this causes voltage transients, bias perturbations, or signal distortion. The effect is more pronounced in narrow-geometry devices and high-speed circuits, where transitions occur rapidly and charge redistribution is incomplete.\nPrevention:\nThe most effective mitigation is careful routing and shielding.\nHigh-impedance nodes are kept as short as possible, routed away from noisy or switching signals, and, where feasible, enclosed by ground shields connected to quiet references (AVSS).\nIn differential circuits, balanced and symmetric routing ensures that any residual injected charge appears as a common-mode disturbance, which is then rejected by the amplifier’s differential nature.\nIn networks involving switching (e.g., current-steering DACs or sample-and-hold circuits), bottom-plate switching and complementary transistor pairs are used to cancel charge injection. In static bias networks, minimizing gate–drain overlap and ensuring sufficient separation from high-slew-rate lines further reduces this parasitic coupling.\nIn summary, understanding these parasitic mechanisms is essential for robust analog design. Each represents a different physical coupling path through the substrate, interconnect, or process environment and each must be addressed at layout level.\nThe preventive strategies applied in this work, derived from the IHP SG13G2 PDK rules and the guidelines in [1], ensure that the layout not only meets design rules but also preserves electrical integrity and long-term reliability in fabrication and operation.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#guard-rings-local-substrate-sinks---saviour",
    "href": "content/_sec_parasitics_prevention.html#guard-rings-local-substrate-sinks---saviour",
    "title": "10  Parasitics and Prevention",
    "section": "10.4 Guard Rings (Local Substrate Sinks) - Saviour",
    "text": "10.4 Guard Rings (Local Substrate Sinks) - Saviour\nGuard rings are a fundamental structural element for substrate noise suppression and latch-up prevention in analog and mixed-signal IC layouts.\nThey consist of diffusion regions tied to power rails that form a low-impedance sink for substrate currents and injected minority carriers. When nearby transistors switch, charge is injected into the substrate or well regions, creating potential fluctuations that can couple into sensitive nodes. Guard rings intercept these currents and route them to a stable potential (AVDD or AVSS), thereby reducing parasitic coupling, improving device reliability, and stabilizing substrate potentials [1].\nIn physical terms, the substrate and well behave as resistive media represented by Rsub (substrate resistance) and Rwell (well resistance).\nBoth parameters define the degree of electrical isolation between neighboring devices.\nA high \\(R_{\\text{sub}}\\) or \\(R_{\\text{well}}\\) increases the voltage drop caused by substrate or well currents, thereby amplifying potential modulation and noise coupling. Guard rings effectively lower these resistances by providing parallel, low-resistance paths to the respective power rails.\nThis ensures that any injected charge is quickly dissipated, keeping local substrate potentials nearly constant.\nReducing \\(R_{\\text{sub}}\\) and \\(R_{\\text{well}}\\) is therefore essential not only for latch-up prevention, but also for matching accuracy in precision analog circuits, where small potential gradients can alter threshold voltages and current ratios.\nIn this work, every sensitive device group including the differential input pair, active loads, and current mirrors is enclosed by fully closed rectangular guard rings.\nFor NMOS devices placed in the p-substrate region, p⁺ guard rings are tied to AVSS (analog ground), while for PMOS devices inside n-wells, n⁺ guard rings are connected to AVDD.\nThis configuration ensures that both substrate and well domains have firm voltage references, minimizing variations in local body potential and suppressing latch-up triggering paths. Contacts are inserted at regular pitch along the ring, effectively reducing the sheet resistance of the ring and enhancing current collection efficiency.\nFrom a design standpoint, several parameters determine guard-ring effectiveness:\n- Ring width : Wider guard rings exhibit lower resistance and better current collection but consume additional layout area.\n- Contact density : A higher number of substrate or well contacts per unit length lowers \\(R_{\\text{sub}}\\) and \\(R_{\\text{well}}\\), improving isolation.\n- Continuity : Continuous guard rings provide stronger confinement of the local substrate potential, while segmented ones trade isolation for area and routing flexibility.\nTwo topological categories are widely used:\n\nContinuous Guard Rings\nThese structures completely enclose the protected device region without any breaks.\nThey offer maximum isolation, lowest effective substrate resistance, and best protection against latch-up and substrate noise.\nContinuous rings are preferred in high-precision analog blocks where low \\(R_{\\text{sub}}\\) and \\(R_{\\text{well}}\\) are crucial for stable operation.\nIn our OTA layout, every critical block especially the differential pair is enclosed by continuous rectangular guard rings, chosen for their strong isolation and reliability.\nSegmented Guard Rings\nThese are composed of discrete diffusion segments separated by intentional openings to accommodate routing or area constraints.\nWhile they exhibit higher \\(R_{\\text{sub}}\\) and reduced isolation compared to continuous rings, properly designed segmented rings can still prevent latch-up and effectively attenuate substrate coupling. They are often used in moderately sensitive or space-limited blocks.\n\nIn conclusion, the guard-ring network in this layout not only suppresses substrate coupling and latch-up but also reduces Rsub and Rwell, anchoring the local substrate and well potentials to fixed references.\nThis ensures stable device behavior across temperature and process variations and significantly enhances long-term reliability of the analog core.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#block-level-practices-implemented-in-this-work",
    "href": "content/_sec_parasitics_prevention.html#block-level-practices-implemented-in-this-work",
    "title": "10  Parasitics and Prevention",
    "section": "10.5 Block-Level Practices Implemented in This Work",
    "text": "10.5 Block-Level Practices Implemented in This Work\n\nPer-group isolation. The differential pair, active load, and current-mirror groups are each enclosed by complete guard rings and placed inside deep N-well/isolation where available, creating local “quiet islands.”\n\nLayer strategy. Sensitive differentials avoid same-layer, long parallel runs. When proximity is required, we route on \\(M_n\\) vs. \\(M_{n+2}\\) with adequate spacing; orthogonal adjacency between Mn and Mn+1 is preferred for crossings.\n\nDecoupling. Local decoupling mosfets (e.g., from AVDD to AVSS) are placed close to the OTA core, especially around the input pair, with short, wide connections and redundant vias inside the same isolation domain.\n\nSymmetry. Wherever matching matters, we keep equal lengths, matched via stacks, and balanced shields on both branches so parasitics affect each side equally.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_parasitics_prevention.html#practical-checklist-analog-focused",
    "href": "content/_sec_parasitics_prevention.html#practical-checklist-analog-focused",
    "title": "10  Parasitics and Prevention",
    "section": "10.6 Practical Checklist (Analog-Focused)",
    "text": "10.6 Practical Checklist (Analog-Focused)\n\nPlan isolation first. Assign deep-N-well/guard-ring envelopes before routing.\n\nRoute high-Z nodes last. Keep them shortest; add shields only if you can mirror them.\n\nAvoid parallelism. No long, same-layer parallels on sensitive nets; prefer Mn vs. Mn+2.\n\nUse via arrays. Add redundancy and enforce symmetry across matched paths.\n\nPlace decaps locally. Near the most sensitive block (here, the differential pair).\n\nRe-run checks often. DRC + antenna + density after small edits; extract and inspect parasitics on critical nodes early.\n\n\n\n\n\n\n\nPro Tip - Parasitics Are Design Variables\n\n\n\nTreat coupling capacitances, substrate returns, and via resistances as designable quantities. Early floorplanning of isolation, ring continuity, layer assignment, and decap placement saves orders of magnitude in late-stage debugging and protects analog performance margins [1].\n\n\n\n\n\n\n[1] J. Lienig and J. Scheible, Fundamentals of layout design for electronic circuits. Springer International Publishing, 2020. doi: 10.1007/978-3-030-39284-0.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parasitics and Prevention</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html",
    "href": "content/_sec_layout_finalsteps.html",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "",
    "text": "11.1 The Seal Ring: Mechanical and Electrical Protection\nAfter completing device-level layout, parasitic-aware routing, and full DRC/LVS verification, the final stage of physical design is the construction of the pad frame and the seal ring.\nThese structures are the physical interface between the silicon die and the outside world. Although electrically simple, they are mechanically and parasitically critical, as they determine whether the fabricated chip can be safely diced, bonded, packaged, and measured.\nIn the SG13G2 process, the IHP-PDK provides a fully parameterized library of PCells for bond pads, ESD structures, and seal rings, which we used and adapted for our layout.\nThe seal ring is a continuous frame of thick metal that surrounds the entire active layout region. Its primary function is mechanical protection during wafer dicing: when the wafer is cut, cracks can propagate inward from the die edge. The seal ring absorbs these stresses and prevents them from reaching active devices.\nBeyond its mechanical role, the seal ring also acts as a low-impedance electrical shield, tied to AVSS, providing:\nIn the SG13G2 PDK, the seal ring is provided as a P_Cell (parameterized cell), built from stacked metal layers and dense via walls. Its geometry is fully adjustable width, margin, and spacing can be tuned allowing the designer to adapt it to the die dimensions while maintaining foundry compliance.\nFor this work, we instantiated and customized the provided seal ring PCell and placed it around the complete pad frame, ensuring full mechanical and electrical enclosure of the analog OTA core.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#the-seal-ring-mechanical-and-electrical-protection",
    "href": "content/_sec_layout_finalsteps.html#the-seal-ring-mechanical-and-electrical-protection",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "",
    "text": "protection against environmental contamination and moisture diffusion,\n\nsuppression of substrate noise entering from the die periphery,\n\nconfinement of parasitic surface currents.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#bond-pads-and-external-interfacing",
    "href": "content/_sec_layout_finalsteps.html#bond-pads-and-external-interfacing",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "11.2 Bond Pads and External Interfacing",
    "text": "11.2 Bond Pads and External Interfacing\n\n11.2.1 Purpose and Structure\nBond pads form the electrical interface between the on-chip metal layers and the external package or measurement environment.\nEach pad is a large, top-metal landing area with a passivation opening, designed to withstand mechanical bonding forces while maintaining low series resistance.\nTo minimize parasitic disturbance, each functional bond pad was further surrounded by a dummy pad frame; a ring of electrically inactive pads. These dummy pads act as protective buffers: if parasitic displacement currents or surface leakage occur near the die edge, they discharge into the dummy pads rather than coupling into the functional I/O pads. This arrangement reduces the susceptibility of the pad ring to noise and preserves the integrity of the sensitive analog connections.[1]\nThe placement of pads was also optimized to minimize parasitic capacitive coupling to the underlying analog core. Pads were spaced to avoid long parallel overlaps with internal routing, and their distribution was balanced to avoid asymmetries in substrate stress and top-metal loading.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#bonding-techniques-wire-bonding-vs.-flip-chip",
    "href": "content/_sec_layout_finalsteps.html#bonding-techniques-wire-bonding-vs.-flip-chip",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "11.3 Bonding Techniques: Wire Bonding vs. Flip-Chip",
    "text": "11.3 Bonding Techniques: Wire Bonding vs. Flip-Chip\nTwo principal bonding methods exist in industry, each with distinct process and performance characteristics.\n\n11.3.1 Wire Bonding\nWire bonding uses thin gold or aluminum wires, thermosonically welded between the pad and the package lead.\nIt is widely used for low- to medium-pin-count analog ICs because:\n\nit requires minimal packaging infrastructure,\n\npads can be placed on the periphery,\n\nthe process is accessible and cost-effective,\n\nbare dies can be bonded directly without redistribution layers.\n\nFor this project intended for bare-die evaluation wire bonding was the natural choice and fully supported by the SG13G2 pad library.\n\n\n11.3.2 Flip-Chip Bonding\nFlip-chip uses solder microbumps on the die surface, flipping the die face-down onto the substrate.\nIt offers extremely low-inductance interconnects but demands:\n\nredistribution layers,\n\nspecialized bump-formation equipment,\n\nunderfill materials,\n\nand advanced assembly infrastructure.\n\nThese requirements go beyond the scope of a prototype analog OTA; therefore, flip-chip pads were not used.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#pad-geometry-orthogonal-vs.-square-pads",
    "href": "content/_sec_layout_finalsteps.html#pad-geometry-orthogonal-vs.-square-pads",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "11.4 Pad Geometry: Orthogonal vs. Square Pads",
    "text": "11.4 Pad Geometry: Orthogonal vs. Square Pads\nBond pad geometry influences both mechanical reliability and parasitic loading.\nClassical square pads are straightforward but can concentrate mechanical stress at their sharp corners during bonding. To mitigate this, the SG13G2 PDK also offers orthogonal (octagonal) pads, which soften corner transitions and distribute force more evenly across the pad boundary.\nThey inherently reduce the tendency for:\n\nmetal delamination,\n\npassivation cracking,\n\nand edge-induced parasitic capacitive coupling.\n\nIn this design, orthogonal octagonal pads were selected for all I/O connections, ensuring robust bonding and improved parasitic behavior relative to simple square geometries.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#esd-protection",
    "href": "content/_sec_layout_finalsteps.html#esd-protection",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "11.5 ESD Protection",
    "text": "11.5 ESD Protection\nElectrostatic discharge (ESD) can destroy sensitive analog devices long before a chip is ever powered in the lab.\nTo prevent this, the SG13G2 PDK provides a series of ESD protection PCells, including:\n\ndiode clamps,\n\ngrounded-gate NMOS structures\n\nPCells are invaluable because they embed foundry-validated device geometries, with correct well biasing, spacing rules, finger structures, and metal enclosures. Designing ESD structures manually would risk violating subtle DRC rules particularly those related to well spacing, diffusion density, and metal overlap.\nBy using the PDK-provided PCells, the pad frame automatically complies with:\n\nESD breakdown voltage limits,\n\nsafe discharge paths during bonding and handling,\n\nand all SG13G2-specific reliability constraints.\n\nAlthough not all ESD structures were required for our simple OTA test chip, their availability ensured that the pad frame could be expanded into a full mixed-signal environment if needed.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_layout_finalsteps.html#density-fill-structures-metal-active-and-poly-fillers",
    "href": "content/_sec_layout_finalsteps.html#density-fill-structures-metal-active-and-poly-fillers",
    "title": "11  Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration",
    "section": "11.6 Density Fill Structures (Metal, Active, and Poly Fillers)",
    "text": "11.6 Density Fill Structures (Metal, Active, and Poly Fillers)\nThe final step before tape-out is the insertion of density fill structures, often simply referred to as fillers. Modern fabrication processes require that each metal, diffusion, and polysilicon layer maintain a specified pattern density within every local window of the layout. These density rules prevent issues such as erosion, and non-uniform planarization during CMP (Chemical–Mechanical Polishing), which can adversely affect metal thickness, resistance, and interlayer dielectric integrity.\nFillers are non-functional geometries typically small, repeatable patterns of metal, active diffusion, and gate poly that ensure the overall layout meets the foundry’s density requirements without altering circuit behavior.\nThey are deliberately placed far from sensitive analog nodes or designed with grounded landing points so that any residual capacitive effect remains negligible. In analog circuits, filler insertion must be performed carefully to avoid parasitic loading of high-impedance nodes or unintentional coupling to bias networks.\nThe IHP-SG13G2 PDK provides automated filler-generation utilities that greatly simplify this process.\nFilling can be performed directly within KLayout using built-in irreversible function, or, more robustly, through a Python script supplied by the PDK, which analyzes layer densities and inserts the appropriate fill shapes according to process-specific rules.\nThe script outputs a final GDS2 file in which all required fills metal, active, and poly have been inserted and you have to verify against the SG13G2 density constraints.\nThis finalized and verified, density-compliant GDS2 file represents the manufacturing-ready layout, suitable for submission to the foundry in compliance with all CMP and density specifications.\n\n\n\n\n[1] B. Razavi, Design of analog CMOS integrated circuits. McGraw-Hill, 2011.",
    "crumbs": [
      "Physical Design",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Final Layout Steps - Bonding, Seal Ring, and Pad-Frame Integration</span>"
    ]
  },
  {
    "objectID": "content/_sec_postlayout_simulation.html",
    "href": "content/_sec_postlayout_simulation.html",
    "title": "12  Post layout simulation.",
    "section": "",
    "text": "We have established testbenches for DC, AC, and transient analysis using the symbol of the designed inverter as a subcircuit. The next step is to perform post-layout simulation by replacing the schematic netlist with the extracted layout netlist (PEX), in order to verify whether the performance remains consistent after layout parasitics are included.\nFirstly we need to open the symbol file in Xschem, edit the properties of the symbol See Figure 12.1. Change from subcircuit to primitive.\n\n\n\n\n\n\nFigure 12.1: Primitive\n\n\n\nOnce changed to primitive, now we can include the .spice file or .cir file from layout to the testbench. See Figure 12.2\n\n\n\n\n\n\nFigure 12.2: Include\n\n\n\nOnce the file is declared, we can run the testbench.\n\n\n\n\n\n\nCorrect pin order\n\n\n\nIt is critically important to match the order of pins and their names. The pin order and names in the .cir files need to be exact same as included in the testbench. See the figures mentioned below\n\n\n \nPost layout and prelayout graphs to be added here as results\n\n\n\n\n\n\nFigure 12.3: Postlayout Results",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Post layout simulation.</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_pex.html",
    "href": "content/_sec_OTA_pex.html",
    "title": "13  PEX",
    "section": "",
    "text": "13.1 Why Do We Need PEX?\nParasitic Extraction (PEX) is a critical step in analog IC design that occurs after layout and before final verification/tapeout. It models the unintended resistive and capacitive effects introduced by routing, device placement, and proximity in silicon.\nIn analog circuits — especially precision blocks like folded cascode OTAs — these parasitics significantly affect performance, making PEX-based simulations essential.\nFor a folded cascode OTA, RC + CC extraction is essential. It ensures layout-induced degradation is captured early in simulation, enabling confident tapeout. Neglecting coupling capacitance or interconnect resistance can lead to significant performance loss or instability in silicon.",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>PEX</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_pex.html#why-do-we-need-pex",
    "href": "content/_sec_OTA_pex.html#why-do-we-need-pex",
    "title": "13  PEX",
    "section": "",
    "text": "Reason\nDescription\n\n\n\n\nPerformance Degradation\nParasitic capacitance reduces bandwidth and phase margin.\n\n\nOffset and Mismatch Effects\nParasitic coupling causes imbalance in differential paths.\n\n\nStability Impact\nAdditional phase lag from parasitics can destabilize feedback loops.\n\n\nPost-Layout Verification\nConfirms that layout did not violate design intent (gain, UGB, PSRR, etc.).\n\n\nTapeout Confidence\nEnsures high correlation between simulation and silicon behavior.",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>PEX</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_pex.html#pex-using-klayout-pex-tool",
    "href": "content/_sec_OTA_pex.html#pex-using-klayout-pex-tool",
    "title": "13  PEX",
    "section": "13.2 PEX using Klayout-PEX tool",
    "text": "13.2 PEX using Klayout-PEX tool\nIIC-OSIC-Tools comes with pre-installed tool called as K-pex. The current status of KLayout-PEX says as following:\nAvailable KLayout PEX Engines:\n\n\n\n\n\n\n\n\n\nEngine\nPEX Type\nStatus\nDescription\n\n\n\n\nKPEX/MAGIC\nCC, RC\nUsable\nWrapper engine, using installed magic tool\n\n\nKPEX/FasterCap\nCC\nUsable, pending QA\nField solver engine using FasterCap\n\n\nKPEX/FastHenry2\nR, L\nPlanned\nField solver engine using FastHenry2\n\n\nKPEX/2.5D\nCC\nUnder construction\nPrototype engine implementing MAGIC concepts/formulas with KLayout means\n\n\nKPEX/2.5D\nR, RC\nPlanned\nPrototype engine implementing MAGIC concepts/formulas with KLayout means",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>PEX</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_pex.html#running-the-kpexmagic-engine",
    "href": "content/_sec_OTA_pex.html#running-the-kpexmagic-engine",
    "title": "13  PEX",
    "section": "13.3 Running the KPEX/MAGIC Engine",
    "text": "13.3 Running the KPEX/MAGIC Engine\nThe magic section of kpex --help describes the arguments and their defaults. Important arguments:\n\n--magicrc: specify location of the magicrc file\n\n--gds: path to the GDS input layout\n\n--magic: enable magic engine\n\n\n13.3.1 Example Command\nkpex --pdk ihp_sg13g2 --magic --gds GDS_PATH --out_dir OUTPUT_DIR_PATH\nmore to kpex can be found under the command kpex --help\n`kpex --help` command gives us the complete list of useful commands in order to understand the usage of KPEX\nOnce PEX is succesfully done, the extracted netlist SPICE file will be generated in the provided output path, which consists of extracted parasitics which can be further used to do post layout simulations and verify whether the design layout satisfies the design specifications or not.",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>PEX</span>"
    ]
  },
  {
    "objectID": "content/_sec_OTA_pex.html#observations-and-practical-results",
    "href": "content/_sec_OTA_pex.html#observations-and-practical-results",
    "title": "13  PEX",
    "section": "13.4 Observations and Practical Results",
    "text": "13.4 Observations and Practical Results\nDuring this work, the 2025.05 Docker release of IIC-OSIC-Tools was used, since the design was submitted on 21 August 2025, and subsequent debugging was performed in that version. When running the FasterCap engine, the process executed successfully; however, the generated .pex.spice file was empty, indicating that no valid parasitic data were written. Conversely, when using the MAGIC engine, a .pex.spice file was generated but contained improperly scaled parameters, leading to simulation inconsistencies.\nUpon investigation of the official IIC-OSIC-Tools release notes, it was confirmed that in the 2025.07 update, the developers temporarily removed klayout-pex due to incompatibility with several dependencies.\nThis subsequent removal confirms that the encountered issues in the 2025.05 environment were indeed genuine tool-level compatibility problems, not user-level errors. Therefore, for this design, PEX-based post-layout simulations were omitted, and circuit validation was based on pre-layout verification complemented by manual parasitic estimation from layout dimensions.",
    "crumbs": [
      "Post-Layout Simulation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>PEX</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Bibliography",
    "section": "",
    "text": "[1] I.\nPDK, “SG13G2 IHP open source layout rules,” Leibniz\nInstitute for High Performance Microelectronics, Design Reference, Dec.\n2024.\n\n\n[2] P.\nG. A. Jespers and B. Murmann, Systematic design of analog CMOS\ncircuits: Using pre-computed lookup tables. Cambridge University\nPress, 2017.\n\n\n[3] B.\nRazavi, Design of analog CMOS integrated circuits. McGraw-Hill,\n2001.\n\n\n[4] B.\nRazavi, Design of analog CMOS integrated circuits. McGraw-Hill,\n2011.\n\n\n[5] R.\nJ. Baker, CMOS: Circuit design, layout, and\nsimulation, 3rd ed. Wiley-IEEE Press, 2010, p. 1208. doi: 10.1002/9780470891179.\n\n\n[6] J.\nLienig and J. Scheible, Fundamentals of layout design for electronic\ncircuits. Springer International Publishing, 2020. doi: 10.1007/978-3-030-39284-0.\n\n\n[7] B.\nWicht, “Analog building blocks of dc-dc converters: Examining\nfundamental concepts,” IEEE Solid-State Circuits\nMagazine, vol. 12, no. 3, pp. 42–47, 2020, doi: 10.1109/mssc.2020.3002141.",
    "crumbs": [
      "Bibliography"
    ]
  },
  {
    "objectID": "content/_appendix_C.html",
    "href": "content/_appendix_C.html",
    "title": "Appendix C — USB-Stick",
    "section": "",
    "text": "thesis_hp/\n├── .gitattributes\n├── .gitignore\n├── _book/\n├── _quarto/\n├── _quarto.yml\n├── _bibliography\n├── _manuscript\n├── index.qmd             # Main project page / Abstract\n├── README.md\n├── references.qmd\n├── KNOWN_ISSUES.md\n├── cace/                 # CACE setup for corner alaysis, PVT, MonteCarlo.\n├── content/              # contains all the .qmd files for documentation\n├── Designs/              # Top-level Design Folder\n│   ├── 1_schematics/     # (Design subfolder: Circuit schematics)\n        ├── otas          # contains .sch files of otas\n│   ├── 2_layout/         # (Design subfolder: Physical layout files)\n│   └── 3_kpex/           # (Design subfolder: Extracted parasitic netlists)\n├── Expose_HP/            \n├── figures/              # contains all the figues for documentation\n├── layout_scripts/       # Python scripts specific to physical layout generation/checking\n├── Literature/           # References or literature review material\n├── python_codes/         # Python scripts to plot raw data\n├── sizing/\n    ├── matlab            # contains matlab codes for lookup tables \n    ├── python            # sizing using pygmid tool and python scripts for sizing\n    ├── xschem            # contains testbenches on mosfets to Extract data from the mosfets  \n                          # provided by foundry in order to use them for gm id method\n├── simulations/          # Folder for .spice files and .raw outputs\n└── postlayout_simulations/   # Post-Layout Simulation results/setup",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>USB-Stick</span>"
    ]
  }
]